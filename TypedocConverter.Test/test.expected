namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    enum AccessibilitySupport
    {
        Disabled = 1,
        Enabled = 2,
        /// <summary>
        /// This should be the browser case where it is not known if a screen reader is attached or no.
        /// </summary>
        Unknown = 0
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A positioning preference for rendering content widgets.
    /// </summary>
    enum ContentWidgetPositionPreference
    {
        /// <summary>
        /// Place the content widget above a position
        /// </summary>
        ABOVE = 1,
        /// <summary>
        /// Place the content widget below a position
        /// </summary>
        BELOW = 2,
        /// <summary>
        /// Place the content widget exactly at a position
        /// </summary>
        EXACT = 0
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Describes the reason the cursor has changed its position.
    /// </summary>
    enum CursorChangeReason
    {
        /// <summary>
        /// A `model.setValue()` was called.
        /// </summary>
        ContentFlush = 1,
        /// <summary>
        /// There was an explicit user gesture.
        /// </summary>
        Explicit = 3,
        /// <summary>
        /// Unknown or not set.
        /// </summary>
        NotSet = 0,
        /// <summary>
        /// There was a Paste.
        /// </summary>
        Paste = 4,
        /// <summary>
        /// The `model` has been changed outside of this cursor and the cursor recovers its position from associated markers.
        /// </summary>
        RecoverFromMarkers = 2,
        /// <summary>
        /// There was a Redo.
        /// </summary>
        Redo = 6,
        /// <summary>
        /// There was an Undo.
        /// </summary>
        Undo = 5
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The default end of line to use when instantiating models.
    /// </summary>
    enum DefaultEndOfLine
    {
        /// <summary>
        /// Use carriage return and line feed (\r\n) as the end of line character.
        /// </summary>
        CRLF = 2,
        /// <summary>
        /// Use line feed (\n) as the end of line character.
        /// </summary>
        LF = 1
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for auto indentation in the editor
    /// </summary>
    enum EditorAutoIndentStrategy
    {
        Advanced = 3,
        Brackets = 2,
        Full = 4,
        Keep = 1,
        None = 0
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    enum EditorOption
    {
        AcceptSuggestionOnCommitCharacter = 0,
        AcceptSuggestionOnEnter = 1,
        AccessibilityPageSize = 3,
        AccessibilitySupport = 2,
        AriaLabel = 4,
        AutoClosingBrackets = 5,
        AutoClosingOvertype = 6,
        AutoClosingQuotes = 7,
        AutoIndent = 8,
        AutoSurround = 10,
        AutomaticLayout = 9,
        CodeLens = 11,
        CodeLensFontFamily = 12,
        CodeLensFontSize = 13,
        ColorDecorators = 14,
        ColumnSelection = 15,
        Comments = 16,
        Contextmenu = 17,
        CopyWithSyntaxHighlighting = 18,
        CursorBlinking = 19,
        CursorSmoothCaretAnimation = 20,
        CursorStyle = 21,
        CursorSurroundingLines = 22,
        CursorSurroundingLinesStyle = 23,
        CursorWidth = 24,
        DefinitionLinkOpensInPeek = 72,
        DisableLayerHinting = 25,
        DisableMonospaceOptimizations = 26,
        DragAndDrop = 27,
        EditorClassName = 121,
        EmptySelectionClipboard = 28,
        ExtraEditorClassName = 29,
        FastScrollSensitivity = 30,
        Find = 31,
        FixedOverflowWidgets = 32,
        Folding = 33,
        FoldingHighlight = 35,
        FoldingStrategy = 34,
        FontFamily = 37,
        FontInfo = 38,
        FontLigatures = 39,
        FontSize = 40,
        FontWeight = 41,
        FormatOnPaste = 42,
        FormatOnType = 43,
        GlyphMargin = 44,
        GotoLocation = 45,
        HideCursorInOverviewRuler = 46,
        HighlightActiveIndentGuide = 47,
        Hover = 48,
        InDiffEditor = 49,
        InlineHints = 120,
        LayoutInfo = 124,
        LetterSpacing = 50,
        Lightbulb = 51,
        LineDecorationsWidth = 52,
        LineHeight = 53,
        LineNumbers = 54,
        LineNumbersMinChars = 55,
        LinkedEditing = 56,
        Links = 57,
        MatchBrackets = 58,
        Minimap = 59,
        MouseStyle = 60,
        MouseWheelScrollSensitivity = 61,
        MouseWheelZoom = 62,
        MultiCursorMergeOverlapping = 63,
        MultiCursorModifier = 64,
        MultiCursorPaste = 65,
        OccurrencesHighlight = 66,
        OverviewRulerBorder = 67,
        OverviewRulerLanes = 68,
        Padding = 69,
        ParameterHints = 70,
        PeekWidgetDefaultFocus = 71,
        PixelRatio = 122,
        QuickSuggestions = 73,
        QuickSuggestionsDelay = 74,
        ReadOnly = 75,
        RenameOnType = 76,
        RenderControlCharacters = 77,
        RenderFinalNewline = 79,
        RenderIndentGuides = 78,
        RenderLineHighlight = 80,
        RenderLineHighlightOnlyWhenFocus = 81,
        RenderValidationDecorations = 82,
        RenderWhitespace = 83,
        RevealHorizontalRightPadding = 84,
        RoundedSelection = 85,
        Rulers = 86,
        ScrollBeyondLastColumn = 88,
        ScrollBeyondLastLine = 89,
        ScrollPredominantAxis = 90,
        Scrollbar = 87,
        SelectOnLineNumbers = 93,
        SelectionClipboard = 91,
        SelectionHighlight = 92,
        ShowDeprecated = 119,
        ShowFoldingControls = 94,
        ShowUnused = 95,
        SmartSelect = 97,
        SmoothScrolling = 98,
        SnippetSuggestions = 96,
        StickyTabStops = 99,
        StopRenderingLineAfter = 100,
        Suggest = 101,
        SuggestFontSize = 102,
        SuggestLineHeight = 103,
        SuggestOnTriggerCharacters = 104,
        SuggestSelection = 105,
        TabCompletion = 106,
        TabFocusMode = 123,
        TabIndex = 107,
        UnfoldOnClickAfterEndOfLine = 36,
        UnusualLineTerminators = 108,
        UseTabStops = 109,
        WordSeparators = 110,
        WordWrap = 111,
        WordWrapBreakAfterCharacters = 112,
        WordWrapBreakBeforeCharacters = 113,
        WordWrapColumn = 114,
        WordWrapOverride1 = 115,
        WordWrapOverride2 = 116,
        WrappingIndent = 117,
        WrappingInfo = 125,
        WrappingStrategy = 118
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// End of line character preference.
    /// </summary>
    enum EndOfLinePreference
    {
        /// <summary>
        /// Use carriage return and line feed (\r\n) as the end of line character.
        /// </summary>
        CRLF = 2,
        /// <summary>
        /// Use line feed (\n) as the end of line character.
        /// </summary>
        LF = 1,
        /// <summary>
        /// Use the end of line character identified in the text buffer.
        /// </summary>
        TextDefined = 0
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// End of line character preference.
    /// </summary>
    enum EndOfLineSequence
    {
        /// <summary>
        /// Use carriage return and line feed (\r\n) as the end of line character.
        /// </summary>
        CRLF = 1,
        /// <summary>
        /// Use line feed (\n) as the end of line character.
        /// </summary>
        LF = 0
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Position in the minimap to render the decoration.
    /// </summary>
    enum MinimapPosition
    {
        Gutter = 2,
        Inline = 1
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Type of hit element with the mouse in the editor.
    /// </summary>
    enum MouseTargetType
    {
        /// <summary>
        /// Mouse is on top of empty space in the content (e.g. after line text or below last line)
        /// </summary>
        CONTENTEMPTY = 7,
        /// <summary>
        /// Mouse is on top of text in the content.
        /// </summary>
        CONTENTTEXT = 6,
        /// <summary>
        /// Mouse is on top of a view zone in the content.
        /// </summary>
        CONTENTVIEWZONE = 8,
        /// <summary>
        /// Mouse is on top of a content widget.
        /// </summary>
        CONTENTWIDGET = 9,
        /// <summary>
        /// Mouse is on top of the glyph margin
        /// </summary>
        GUTTERGLYPHMARGIN = 2,
        /// <summary>
        /// Mouse is on top of the line decorations
        /// </summary>
        GUTTERLINEDECORATIONS = 4,
        /// <summary>
        /// Mouse is on top of the line numbers
        /// </summary>
        GUTTERLINENUMBERS = 3,
        /// <summary>
        /// Mouse is on top of the whitespace left in the gutter by a view zone.
        /// </summary>
        GUTTERVIEWZONE = 5,
        /// <summary>
        /// Mouse is outside of the editor.
        /// </summary>
        OUTSIDEEDITOR = 13,
        /// <summary>
        /// Mouse is on top of an overlay widget.
        /// </summary>
        OVERLAYWIDGET = 12,
        /// <summary>
        /// Mouse is on top of the decorations overview ruler.
        /// </summary>
        OVERVIEWRULER = 10,
        /// <summary>
        /// Mouse is on top of a scrollbar.
        /// </summary>
        SCROLLBAR = 11,
        /// <summary>
        /// Mouse is on top of the textarea used for input.
        /// </summary>
        TEXTAREA = 1,
        /// <summary>
        /// Mouse is on top of an unknown element.
        /// </summary>
        UNKNOWN = 0
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A positioning preference for rendering overlay widgets.
    /// </summary>
    enum OverlayWidgetPositionPreference
    {
        /// <summary>
        /// Position the overlay widget in the bottom right corner
        /// </summary>
        BOTTOMRIGHTCORNER = 1,
        /// <summary>
        /// Position the overlay widget in the top center
        /// </summary>
        TOPCENTER = 2,
        /// <summary>
        /// Position the overlay widget in the top right corner
        /// </summary>
        TOPRIGHTCORNER = 0
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Vertical Lane in the overview ruler of the editor.
    /// </summary>
    enum OverviewRulerLane
    {
        Center = 2,
        Full = 7,
        Left = 1,
        Right = 4
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    enum RenderLineNumbersType
    {
        Custom = 4,
        Interval = 3,
        Off = 0,
        On = 1,
        Relative = 2
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    enum RenderMinimap
    {
        Blocks = 2,
        None = 0,
        Text = 1
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    enum ScrollType
    {
        Immediate = 1,
        Smooth = 0
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    enum ScrollbarVisibility
    {
        Auto = 1,
        Hidden = 2,
        Visible = 3
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The kind of animation in which the editor's cursor should be rendered.
    /// </summary>
    enum TextEditorCursorBlinkingStyle
    {
        /// <summary>
        /// Blinking
        /// </summary>
        Blink = 1,
        /// <summary>
        /// Expand collapse animation on the y axis
        /// </summary>
        Expand = 4,
        /// <summary>
        /// Hidden
        /// </summary>
        Hidden = 0,
        /// <summary>
        /// Blinking with prolonged filled state and smooth fading
        /// </summary>
        Phase = 3,
        /// <summary>
        /// Blinking with smooth fading
        /// </summary>
        Smooth = 2,
        /// <summary>
        /// No-Blinking
        /// </summary>
        Solid = 5
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The style in which the editor's cursor should be rendered.
    /// </summary>
    enum TextEditorCursorStyle
    {
        /// <summary>
        /// As a block (sitting on top of a character).
        /// </summary>
        Block = 2,
        /// <summary>
        /// As an outlined block (sitting on top of a character).
        /// </summary>
        BlockOutline = 5,
        /// <summary>
        /// As a vertical line (sitting between two characters).
        /// </summary>
        Line = 1,
        /// <summary>
        /// As a thin vertical line (sitting between two characters).
        /// </summary>
        LineThin = 4,
        /// <summary>
        /// As a horizontal line (sitting under a character).
        /// </summary>
        Underline = 3,
        /// <summary>
        /// As a thin horizontal line (sitting under a character).
        /// </summary>
        UnderlineThin = 6
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Describes the behavior of decorations when typing/editing near their edges.
    /// Note: Please do not edit the values, as they very carefully match `DecorationRangeBehavior`
    /// </summary>
    enum TrackedRangeStickiness
    {
        AlwaysGrowsWhenTypingAtEdges = 0,
        GrowsOnlyWhenTypingAfter = 3,
        GrowsOnlyWhenTypingBefore = 2,
        NeverGrowsWhenTypingAtEdges = 1
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Describes how to indent wrapped lines.
    /// </summary>
    enum WrappingIndent
    {
        /// <summary>
        /// DeepIndent =&gt; wrapped lines get +2 indentation toward the parent.
        /// </summary>
        DeepIndent = 3,
        /// <summary>
        /// Indent =&gt; wrapped lines get +1 indentation toward the parent.
        /// </summary>
        Indent = 2,
        /// <summary>
        /// No indentation =&gt; wrapped lines begin at column 1.
        /// </summary>
        None = 0,
        /// <summary>
        /// Same =&gt; wrapped lines get the same indentation as the parent.
        /// </summary>
        Same = 1
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    class BareFontInfo
    {
        public BareFontInfo() => throw new System.NotImplementedException();

        [Newtonsoft.Json.JsonProperty("_bareFontInfoBrand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public void BareFontInfoBrand { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("fontFamily", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FontFamily { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("fontFeatureSettings", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FontFeatureSettings { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("fontSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double FontSize { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("fontWeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FontWeight { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("letterSpacing", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double LetterSpacing { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("lineHeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double LineHeight { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("pixelRatio", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double PixelRatio { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("zoomLevel", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double ZoomLevel { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// An event describing that the configuration of the editor has changed.
    /// </summary>
    class ConfigurationChangedEvent
    {
        public ConfigurationChangedEvent() => throw new System.NotImplementedException();

        public bool HasChanged(EditorOption id) => throw new System.NotImplementedException();

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    class FindMatch
    {
        public FindMatch() => throw new System.NotImplementedException();

        [Newtonsoft.Json.JsonProperty("_findMatchBrand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public void FindMatchBrand { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("matches", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string[] Matches { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Range Range { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    class FontInfo : BareFontInfo
    {
        public FontInfo() => throw new System.NotImplementedException();

        [Newtonsoft.Json.JsonProperty("_bareFontInfoBrand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public void BareFontInfoBrand { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("_editorStylingBrand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public void EditorStylingBrand { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("canUseHalfwidthRightwardsArrow", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool CanUseHalfwidthRightwardsArrow { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("fontFamily", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FontFamily { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("fontFeatureSettings", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FontFeatureSettings { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("fontSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double FontSize { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("fontWeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FontWeight { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("isMonospace", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IsMonospace { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("isTrusted", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IsTrusted { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("letterSpacing", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double LetterSpacing { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("lineHeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double LineHeight { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("maxDigitWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double MaxDigitWidth { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("middotWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double MiddotWidth { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("pixelRatio", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double PixelRatio { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("spaceWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double SpaceWidth { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("typicalFullwidthCharacterWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double TypicalFullwidthCharacterWidth { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("typicalHalfwidthCharacterWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double TypicalHalfwidthCharacterWidth { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("version", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double Version { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("wsmiddotWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double WsmiddotWidth { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("zoomLevel", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double ZoomLevel { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    class TextModelResolvedOptions
    {
        public TextModelResolvedOptions() => throw new System.NotImplementedException();

        [Newtonsoft.Json.JsonProperty("_textModelResolvedOptionsBrand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public void TextModelResolvedOptionsBrand { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("defaultEOL", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DefaultEndOfLine DefaultEOL { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("indentSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double IndentSize { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("insertSpaces", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool InsertSpaces { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("tabSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double TabSize { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("trimAutoWhitespace", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool TrimAutoWhitespace { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The internal layout details of the editor.
    /// </summary>
    interface EditorLayoutInfo
    {
        /// <summary>
        /// Left position for the content (actual text)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("contentLeft", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ContentLeft { get; set; }

        /// <summary>
        /// The width of the content (actual text)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("contentWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ContentWidth { get; set; }

        /// <summary>
        /// Left position for the line decorations.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("decorationsLeft", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double DecorationsLeft { get; set; }

        /// <summary>
        /// The width of the line decorations.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("decorationsWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double DecorationsWidth { get; set; }

        /// <summary>
        /// Left position for the glyph margin.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("glyphMarginLeft", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double GlyphMarginLeft { get; set; }

        /// <summary>
        /// The width of the glyph margin.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("glyphMarginWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double GlyphMarginWidth { get; set; }

        /// <summary>
        /// Full editor height.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("height", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Height { get; set; }

        /// <summary>
        /// The height of the horizontal scrollbar.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("horizontalScrollbarHeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double HorizontalScrollbarHeight { get; set; }

        [Newtonsoft.Json.JsonProperty("isViewportWrapping", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IsViewportWrapping { get; set; }

        [Newtonsoft.Json.JsonProperty("isWordWrapMinified", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IsWordWrapMinified { get; set; }

        /// <summary>
        /// Left position for the line numbers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lineNumbersLeft", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double LineNumbersLeft { get; set; }

        /// <summary>
        /// The width of the line numbers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lineNumbersWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double LineNumbersWidth { get; set; }

        /// <summary>
        /// Layout information for the minimap
        /// </summary>
        [Newtonsoft.Json.JsonProperty("minimap", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        EditorMinimapLayoutInfo Minimap { get; set; }

        /// <summary>
        /// The position of the overview ruler.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("overviewRuler", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        OverviewRulerPosition OverviewRuler { get; set; }

        /// <summary>
        /// The width of the vertical scrollbar.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("verticalScrollbarWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double VerticalScrollbarWidth { get; set; }

        /// <summary>
        /// The number of columns (of typical characters) fitting on a viewport line.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("viewportColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ViewportColumn { get; set; }

        /// <summary>
        /// Full editor width.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("width", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Width { get; set; }

        [Newtonsoft.Json.JsonProperty("wrappingColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double WrappingColumn { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The internal layout details of the editor.
    /// </summary>
    interface EditorMinimapLayoutInfo
    {
        [Newtonsoft.Json.JsonProperty("minimapCanvasInnerHeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double MinimapCanvasInnerHeight { get; set; }

        [Newtonsoft.Json.JsonProperty("minimapCanvasInnerWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double MinimapCanvasInnerWidth { get; set; }

        [Newtonsoft.Json.JsonProperty("minimapCanvasOuterHeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double MinimapCanvasOuterHeight { get; set; }

        [Newtonsoft.Json.JsonProperty("minimapCanvasOuterWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double MinimapCanvasOuterWidth { get; set; }

        [Newtonsoft.Json.JsonProperty("minimapHeightIsEditorHeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool MinimapHeightIsEditorHeight { get; set; }

        [Newtonsoft.Json.JsonProperty("minimapIsSampling", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool MinimapIsSampling { get; set; }

        [Newtonsoft.Json.JsonProperty("minimapLeft", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double MinimapLeft { get; set; }

        [Newtonsoft.Json.JsonProperty("minimapLineHeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double MinimapLineHeight { get; set; }

        [Newtonsoft.Json.JsonProperty("minimapScale", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double MinimapScale { get; set; }

        [Newtonsoft.Json.JsonProperty("minimapWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double MinimapWidth { get; set; }

        [Newtonsoft.Json.JsonProperty("renderMinimap", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        RenderMinimap RenderMinimap { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface EditorWrappingInfo
    {
        [Newtonsoft.Json.JsonProperty("isDominatedByLongLines", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IsDominatedByLongLines { get; set; }

        [Newtonsoft.Json.JsonProperty("isViewportWrapping", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IsViewportWrapping { get; set; }

        [Newtonsoft.Json.JsonProperty("isWordWrapMinified", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IsWordWrapMinified { get; set; }

        [Newtonsoft.Json.JsonProperty("wrappingColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double WrappingColumn { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Description of an action contribution
    /// </summary>
    interface IActionDescriptor
    {
        /// <summary>
        /// Control if the action should show up in the context menu and where.
        /// The context menu of the editor has these default:
        ///   navigation - The navigation group comes first in all cases.
        ///   1_modification - This group comes next and contains commands that modify your code.
        ///   9_cutcopypaste - The last default group with the basic editing commands.
        /// You can also create your own group.
        /// Defaults to null (don't show in context menu).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("contextMenuGroupId", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? ContextMenuGroupId { get; set; }

        /// <summary>
        /// Control the order in the context menu group.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("contextMenuOrder", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? ContextMenuOrder { get; set; }

        /// <summary>
        /// An unique identifier of the contributed action.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Id { get; set; }

        /// <summary>
        /// The keybinding rule (condition on top of precondition).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("keybindingContext", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? KeybindingContext { get; set; }

        /// <summary>
        /// An array of keybindings for the action.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("keybindings", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double[]? Keybindings { get; set; }

        /// <summary>
        /// A label of the action that will be presented to the user.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("label", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Label { get; set; }

        /// <summary>
        /// Precondition rule.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("precondition", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Precondition { get; set; }

        /// <summary>
        /// Method that will be executed when the action is triggered.
        /// </summary>
        System.Threading.Tasks.Task Run(ICodeEditor editor, object[] args);

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A change
    /// </summary>
    interface IChange
    {
        [Newtonsoft.Json.JsonProperty("modifiedEndLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ModifiedEndLineNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("modifiedStartLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ModifiedStartLineNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("originalEndLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double OriginalEndLineNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("originalStartLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double OriginalStartLineNumber { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A character level change.
    /// </summary>
    interface ICharChange : IChange
    {
        [Newtonsoft.Json.JsonProperty("modifiedEndColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ModifiedEndColumn { get; set; }

        [Newtonsoft.Json.JsonProperty("modifiedStartColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ModifiedStartColumn { get; set; }

        [Newtonsoft.Json.JsonProperty("originalEndColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double OriginalEndColumn { get; set; }

        [Newtonsoft.Json.JsonProperty("originalStartColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double OriginalStartColumn { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A rich code editor.
    /// </summary>
    interface ICodeEditor : IEditor
    {
        /// <summary>
        /// An event emitted on a "contextmenu".
        /// </summary>
        event System.Action<IEditorMouseEvent> OnContextMenu;

        /// <summary>
        /// An event emitted when editing failed because the editor is read-only.
        /// </summary>
        event System.Action OnDidAttemptReadOnlyEdit;

        /// <summary>
        /// An event emitted when the text inside this editor lost focus (i.e. cursor stops blinking).
        /// </summary>
        event System.Action OnDidBlurEditorText;

        /// <summary>
        /// An event emitted when the text inside this editor or an editor widget lost focus.
        /// </summary>
        event System.Action OnDidBlurEditorWidget;

        /// <summary>
        /// An event emitted when the configuration of the editor has changed. (e.g. `editor.updateOptions()`)
        /// </summary>
        event System.Action<ConfigurationChangedEvent> OnDidChangeConfiguration;

        /// <summary>
        /// An event emitted when the cursor position has changed.
        /// </summary>
        event System.Action<ICursorPositionChangedEvent> OnDidChangeCursorPosition;

        /// <summary>
        /// An event emitted when the cursor selection has changed.
        /// </summary>
        event System.Action<ICursorSelectionChangedEvent> OnDidChangeCursorSelection;

        /// <summary>
        /// An event emitted when the model of this editor has changed (e.g. `editor.setModel()`).
        /// </summary>
        event System.Action<IModelChangedEvent> OnDidChangeModel;

        /// <summary>
        /// An event emitted when the content of the current model has changed.
        /// </summary>
        event System.Action<IModelContentChangedEvent> OnDidChangeModelContent;

        /// <summary>
        /// An event emitted when the decorations of the current model have changed.
        /// </summary>
        event System.Action<IModelDecorationsChangedEvent> OnDidChangeModelDecorations;

        /// <summary>
        /// An event emitted when the language of the current model has changed.
        /// </summary>
        event System.Action<IModelLanguageChangedEvent> OnDidChangeModelLanguage;

        /// <summary>
        /// An event emitted when the language configuration of the current model has changed.
        /// </summary>
        event System.Action<IModelLanguageConfigurationChangedEvent> OnDidChangeModelLanguageConfiguration;

        /// <summary>
        /// An event emitted when the options of the current model has changed.
        /// </summary>
        event System.Action<IModelOptionsChangedEvent> OnDidChangeModelOptions;

        /// <summary>
        /// An event emitted when the content width or content height in the editor has changed.
        /// </summary>
        event System.Action<IContentSizeChangedEvent> OnDidContentSizeChange;

        /// <summary>
        /// An event emitted when the text inside this editor gained focus (i.e. cursor starts blinking).
        /// </summary>
        event System.Action OnDidFocusEditorText;

        /// <summary>
        /// An event emitted when the text inside this editor or an editor widget gained focus.
        /// </summary>
        event System.Action OnDidFocusEditorWidget;

        /// <summary>
        /// An event emitted when the layout of the editor has changed.
        /// </summary>
        event System.Action<EditorLayoutInfo> OnDidLayoutChange;

        /// <summary>
        /// An event emitted when users paste text in the editor.
        /// </summary>
        event System.Action<IPasteEvent> OnDidPaste;

        /// <summary>
        /// An event emitted when the scroll in the editor has changed.
        /// </summary>
        event System.Action<IScrollEvent> OnDidScrollChange;

        /// <summary>
        /// An event emitted on a "keydown".
        /// </summary>
        event System.Action<IKeyboardEvent> OnKeyDown;

        /// <summary>
        /// An event emitted on a "keyup".
        /// </summary>
        event System.Action<IKeyboardEvent> OnKeyUp;

        /// <summary>
        /// An event emitted on a "mousedown".
        /// </summary>
        event System.Action<IEditorMouseEvent> OnMouseDown;

        /// <summary>
        /// An event emitted on a "mouseleave".
        /// </summary>
        event System.Action<IPartialEditorMouseEvent> OnMouseLeave;

        /// <summary>
        /// An event emitted on a "mousemove".
        /// </summary>
        event System.Action<IEditorMouseEvent> OnMouseMove;

        /// <summary>
        /// An event emitted on a "mouseup".
        /// </summary>
        event System.Action<IEditorMouseEvent> OnMouseUp;

        /// <summary>
        /// Add a content widget. Widgets must have unique ids, otherwise they will be overwritten.
        /// </summary>
        void AddContentWidget(IContentWidget widget);

        /// <summary>
        /// Add an overlay widget. Widgets must have unique ids, otherwise they will be overwritten.
        /// </summary>
        void AddOverlayWidget(IOverlayWidget widget);

        /// <summary>
        /// Apply the same font settings as the editor to `target`.
        /// </summary>
        void ApplyFontInfo(HTMLElement target);

        /// <summary>
        /// Change the view zones. View zones are lost when a new model is attached to the editor.
        /// </summary>
        void ChangeViewZones(System.Action<IViewZoneChangeAccessor> callback);

        /// <summary>
        /// All decorations added through this call will get the ownerId of this editor.
        /// </summary>
        string[] DeltaDecorations(string[] oldDecorations, IModelDeltaDecoration[] newDecorations);

        /// <summary>
        /// Execute a command on the editor.
        /// The edits will land on the undo-redo stack, but no "undo stop" will be pushed.
        /// </summary>
        void ExecuteCommand(string source, ICommand command);

        /// <summary>
        /// Execute multiple (concomitant) commands on the editor.
        /// </summary>
        void ExecuteCommands(string source, ICommand[] commands);

        /// <summary>
        /// Execute edits on the editor.
        /// The edits will land on the undo-redo stack, but no "undo stop" will be pushed.
        /// </summary>
        bool ExecuteEdits(string source, IIdentifiedSingleEditOperation[] edits, Selection[] endCursorState);

        /// <summary>
        /// Get an action that is a contribution to this editor.
        /// </summary>
        /// <returns>
        /// The action or null if action not found.
        /// 
        /// </returns>
        IEditorAction GetAction(string id);

        /// <summary>
        /// Returns the editor's container dom node
        /// </summary>
        HTMLElement GetContainerDomNode();

        /// <summary>
        /// Get the height of the editor's content.
        /// This is information that is "erased" when computing `scrollHeight = Math.max(contentHeight, height)`
        /// </summary>
        double GetContentHeight();

        /// <summary>
        /// Get the width of the editor's content.
        /// This is information that is "erased" when computing `scrollWidth = Math.max(contentWidth, width)`
        /// </summary>
        double GetContentWidth();

        /// <summary>
        /// Get a contribution of this editor.
        /// </summary>
        /// <returns>
        /// The contribution or null if contribution not found.
        /// 
        /// </returns>
        T GetContribution<T>(string id);

        /// <summary>
        /// Returns the editor's dom node
        /// </summary>
        HTMLElement GetDomNode();

        /// <summary>
        /// Get the layout info for the editor.
        /// </summary>
        EditorLayoutInfo GetLayoutInfo();

        /// <summary>
        /// Get all the decorations on a line (filtering out decorations from other editors).
        /// </summary>
        IModelDecoration[] GetLineDecorations(double lineNumber);

        /// <summary>
        /// Get the horizontal position (left offset) for the column w.r.t to the beginning of the line.
        /// This method works only if the line `lineNumber` is currently rendered (in the editor's viewport).
        /// Use this method with caution.
        /// </summary>
        double GetOffsetForColumn(double lineNumber, double column);

        /// <summary>
        /// Gets a specific editor option.
        /// </summary>
        NonNullable<ComputedEditorOptionValue<object>> GetOption<T>(T id);

        /// <summary>
        /// Gets all the editor computed options.
        /// </summary>
        IComputedEditorOptions GetOptions();

        /// <summary>
        /// Returns the editor's configuration (without any validation or defaults).
        /// </summary>
        IEditorOptions GetRawOptions();

        /// <summary>
        /// Get the scrollHeight of the editor's viewport.
        /// </summary>
        double GetScrollHeight();

        /// <summary>
        /// Get the scrollLeft of the editor's viewport.
        /// </summary>
        double GetScrollLeft();

        /// <summary>
        /// Get the scrollTop of the editor's viewport.
        /// </summary>
        double GetScrollTop();

        /// <summary>
        /// Get the scrollWidth of the editor's viewport.
        /// </summary>
        double GetScrollWidth();

        /// <summary>
        /// Get the visible position for `position`.
        /// The result position takes scrolling into account and is relative to the top left corner of the editor.
        /// Explanation 1: the results of this method will change for the same `position` if the user scrolls the editor.
        /// Explanation 2: the results of this method will not change if the container of the editor gets repositioned.
        /// Warning: the results of this method are inaccurate for positions that are outside the current editor viewport.
        /// </summary>
        TypedocConverter.GeneratedTypes.LiteralDoubleHeightDoubleLeftDoubleTop GetScrolledVisiblePosition(IPosition position);

        /// <summary>
        /// Get the hit test target at coordinates `clientX` and `clientY`.
        /// The coordinates are relative to the top-left of the viewport.
        /// </summary>
        /// <returns>
        /// Hit test target or null if the coordinates fall outside the editor or the editor has no model.
        /// 
        /// </returns>
        IMouseTarget GetTargetAtClientPoint(double clientX, double clientY);

        /// <summary>
        /// Get the vertical position (top offset) for the line w.r.t. to the first line.
        /// </summary>
        double GetTopForLineNumber(double lineNumber);

        /// <summary>
        /// Get the vertical position (top offset) for the position w.r.t. to the first line.
        /// </summary>
        double GetTopForPosition(double lineNumber, double column);

        /// <summary>
        /// Get value of the current model attached to this editor.
        /// </summary>
        string GetValue(TypedocConverter.GeneratedTypes.LiteralStringLineEndingBoolPreserveBOM options);

        /// <summary>
        /// Returns the ranges that are currently visible.
        /// Does not account for horizontal scrolling.
        /// </summary>
        Range[] GetVisibleRanges();

        /// <summary>
        /// Returns true if the text inside this editor or an editor widget has focus.
        /// </summary>
        bool HasWidgetFocus();

        /// <summary>
        /// Layout/Reposition a content widget. This is a ping to the editor to call widget.getPosition()
        /// and update appropriately.
        /// </summary>
        void LayoutContentWidget(IContentWidget widget);

        /// <summary>
        /// Layout/Reposition an overlay widget. This is a ping to the editor to call widget.getPosition()
        /// and update appropriately.
        /// </summary>
        void LayoutOverlayWidget(IOverlayWidget widget);

        /// <summary>
        /// An event emitted after composition has ended.
        /// </summary>
        IDisposable OnDidCompositionEnd(System.Action listener);

        /// <summary>
        /// An event emitted after composition has started.
        /// </summary>
        IDisposable OnDidCompositionStart(System.Action listener);

        /// <summary>
        /// Remove the "undo stop" in the undo-redo stack.
        /// </summary>
        bool PopUndoStop();

        /// <summary>
        /// Create an "undo stop" in the undo-redo stack.
        /// </summary>
        bool PushUndoStop();

        /// <summary>
        /// Remove a content widget.
        /// </summary>
        void RemoveContentWidget(IContentWidget widget);

        /// <summary>
        /// Remove an overlay widget.
        /// </summary>
        void RemoveOverlayWidget(IOverlayWidget widget);

        /// <summary>
        /// Force an editor render now.
        /// </summary>
        void Render(bool forceRedraw);

        /// <summary>
        /// Change the scrollLeft of the editor's viewport.
        /// </summary>
        void SetScrollLeft(double newScrollLeft, ScrollType scrollType);

        /// <summary>
        /// Change the scroll position of the editor's viewport.
        /// </summary>
        void SetScrollPosition(INewScrollPosition position, ScrollType scrollType);

        /// <summary>
        /// Change the scrollTop of the editor's viewport.
        /// </summary>
        void SetScrollTop(double newScrollTop, ScrollType scrollType);

        /// <summary>
        /// Set the value of the current model attached to this editor.
        /// </summary>
        void SetValue(string newValue);

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A (serializable) state of the code editor.
    /// </summary>
    interface ICodeEditorViewState
    {
        [Newtonsoft.Json.JsonProperty("contributionsState", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        System.Collections.Generic.IDictionary<string, object> ContributionsState { get; set; }

        [Newtonsoft.Json.JsonProperty("cursorState", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ICursorState[] CursorState { get; set; }

        [Newtonsoft.Json.JsonProperty("viewState", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IViewState ViewState { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IColorizerElementOptions : IColorizerOptions
    {
        [Newtonsoft.Json.JsonProperty("mimeType", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? MimeType { get; set; }

        [Newtonsoft.Json.JsonProperty("theme", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Theme { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IColorizerOptions
    {
        [Newtonsoft.Json.JsonProperty("tabSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? TabSize { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A command that modifies text / cursor state on a model.
    /// </summary>
    interface ICommand
    {
        /// <summary>
        /// Compute the cursor state after the edit operations were applied.
        /// </summary>
        /// <returns>
        /// The cursor state after the command executed.
        /// 
        /// </returns>
        Selection ComputeCursorState(ITextModel model, ICursorStateComputerData helper);

        /// <summary>
        /// Get the edit operations needed to execute this command.
        /// </summary>
        void GetEditOperations(ITextModel model, IEditOperationBuilder builder);

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface ICommandHandler
    {
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// All computed editor options.
    /// </summary>
    interface IComputedEditorOptions
    {
        NonNullable<ComputedEditorOptionValue<object>> Get<T>(T id);

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IContentSizeChangedEvent
    {
        [Newtonsoft.Json.JsonProperty("contentHeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ContentHeight { get; set; }

        [Newtonsoft.Json.JsonProperty("contentHeightChanged", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool ContentHeightChanged { get; set; }

        [Newtonsoft.Json.JsonProperty("contentWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ContentWidth { get; set; }

        [Newtonsoft.Json.JsonProperty("contentWidthChanged", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool ContentWidthChanged { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A content widget renders inline with the text and can be easily placed 'near' an editor position.
    /// </summary>
    interface IContentWidget
    {
        /// <summary>
        /// Render this content widget in a location where it could overflow the editor's view dom node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("allowEditorOverflow", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AllowEditorOverflow { get; set; }

        [Newtonsoft.Json.JsonProperty("suppressMouseDown", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SuppressMouseDown { get; set; }

        /// <summary>
        /// Optional function that is invoked after rendering the content
        /// widget. Is being invoked with the selected position preference
        /// or `null` if not rendered.
        /// </summary>
        void AfterRender(ContentWidgetPositionPreference position);

        /// <summary>
        /// Optional function that is invoked before rendering
        /// the content widget. If a dimension is returned the editor will
        /// attempt to use it.
        /// </summary>
        IDimension BeforeRender();

        /// <summary>
        /// Get the dom node of the content widget.
        /// </summary>
        HTMLElement GetDomNode();

        /// <summary>
        /// Get a unique identifier of the content widget.
        /// </summary>
        string GetId();

        /// <summary>
        /// Get the placement of the content widget.
        /// If null is returned, the content widget will be placed off screen.
        /// </summary>
        IContentWidgetPosition GetPosition();

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A position for rendering content widgets.
    /// </summary>
    interface IContentWidgetPosition
    {
        /// <summary>
        /// Desired position for the content widget.
        /// `preference` will also affect the placement.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("position", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IPosition Position { get; set; }

        /// <summary>
        /// Placement preference for position, in order of preference.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("preference", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ContentWidgetPositionPreference[] Preference { get; set; }

        /// <summary>
        /// Optionally, a range can be provided to further
        /// define the position of the content widget.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange? Range { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IContextKey<T>
    {
        T Get();

        void Reset();

        void Set(T value);

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// An event describing that the cursor position has changed.
    /// </summary>
    interface ICursorPositionChangedEvent
    {
        /// <summary>
        /// Primary cursor's position.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("position", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Position Position { get; set; }

        /// <summary>
        /// Reason.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reason", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CursorChangeReason Reason { get; set; }

        /// <summary>
        /// Secondary cursors' position.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secondaryPositions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Position[] SecondaryPositions { get; set; }

        /// <summary>
        /// Source of the call that caused the event.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("source", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Source { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// An event describing that the cursor selection has changed.
    /// </summary>
    interface ICursorSelectionChangedEvent
    {
        /// <summary>
        /// The model version id.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("modelVersionId", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ModelVersionId { get; set; }

        /// <summary>
        /// The model version id the that `oldSelections` refer to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("oldModelVersionId", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double OldModelVersionId { get; set; }

        /// <summary>
        /// The old selections.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("oldSelections", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Selection[] OldSelections { get; set; }

        /// <summary>
        /// Reason.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reason", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CursorChangeReason Reason { get; set; }

        /// <summary>
        /// The secondary selections.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secondarySelections", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Selection[] SecondarySelections { get; set; }

        /// <summary>
        /// The primary selection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selection", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Selection Selection { get; set; }

        /// <summary>
        /// Source of the call that caused the event.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("source", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Source { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A (serializable) state of the cursors.
    /// </summary>
    interface ICursorState
    {
        [Newtonsoft.Json.JsonProperty("inSelectionMode", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool InSelectionMode { get; set; }

        [Newtonsoft.Json.JsonProperty("position", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IPosition Position { get; set; }

        [Newtonsoft.Json.JsonProperty("selectionStart", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IPosition SelectionStart { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A callback that can compute the cursor state after applying a series of edit operations.
    /// </summary>
    interface ICursorStateComputer
    {
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A helper for computing cursor state after a command.
    /// </summary>
    interface ICursorStateComputerData
    {
        /// <summary>
        /// Get the inverse edit operations of the added edit operations.
        /// </summary>
        IValidEditOperation[] GetInverseEditOperations();

        /// <summary>
        /// Get a previously tracked selection.
        /// </summary>
        /// <returns>
        /// The selection.
        /// 
        /// </returns>
        Selection GetTrackedSelection(string id);

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IDecorationOptions
    {
        /// <summary>
        /// CSS color to render.
        /// e.g.: rgba(100, 100, 100, 0.5) or a color from the color registry
        /// </summary>
        [Newtonsoft.Json.JsonProperty("color", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ThemeColor Color { get; set; }

        /// <summary>
        /// CSS color to render.
        /// e.g.: rgba(100, 100, 100, 0.5) or a color from the color registry
        /// </summary>
        [Newtonsoft.Json.JsonProperty("darkColor", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ThemeColor? DarkColor { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A rich diff editor.
    /// </summary>
    interface IDiffEditor : IEditor
    {
        /// <summary>
        /// An event emitted when the diff information computed by this diff editor has been updated.
        /// </summary>
        event System.Action OnDidUpdateDiff;

        /// <summary>
        /// Get information based on computed diff about a line number from the modified model.
        /// If the diff computation is not finished or the model is missing, will return null.
        /// </summary>
        IDiffLineInformation GetDiffLineInformationForModified(double lineNumber);

        /// <summary>
        /// Get information based on computed diff about a line number from the original model.
        /// If the diff computation is not finished or the model is missing, will return null.
        /// </summary>
        IDiffLineInformation GetDiffLineInformationForOriginal(double lineNumber);

        /// <summary>
        
        /// </summary>
        HTMLElement GetDomNode();

        /// <summary>
        /// Get the computed diff information.
        /// </summary>
        ILineChange[] GetLineChanges();

        /// <summary>
        /// Get the `modified` editor.
        /// </summary>
        ICodeEditor GetModifiedEditor();

        /// <summary>
        /// Get the `original` editor.
        /// </summary>
        ICodeEditor GetOriginalEditor();

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The options to create a diff editor.
    /// </summary>
    interface IDiffEditorConstructionOptions : IDiffEditorOptions
    {
        /// <summary>
        /// The initial editor dimension (to avoid measuring the container).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dimension", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IDimension? Dimension { get; set; }

        /// <summary>
        /// Place overflow widgets inside an external DOM node.
        /// Defaults to an internal DOM node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("overflowWidgetsDomNode", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        HTMLElement? OverflowWidgetsDomNode { get; set; }

        /// <summary>
        /// Initial theme to be used for rendering.
        /// The current out-of-the-box available themes are: 'vs' (default), 'vs-dark', 'hc-black'.
        /// You can create custom themes via `monaco.editor.defineTheme`.
        /// To switch a theme, use `monaco.editor.setTheme`
        /// </summary>
        [Newtonsoft.Json.JsonProperty("theme", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Theme { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A model for the diff editor.
    /// </summary>
    interface IDiffEditorModel
    {
        /// <summary>
        /// Modified model.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("modified", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ITextModel Modified { get; set; }

        /// <summary>
        /// Original model.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("original", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ITextModel Original { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for the diff editor.
    /// </summary>
    interface IDiffEditorOptions : IEditorOptions
    {
        /// <summary>
        /// Should the diff editor enable code lens?
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("diffCodeLens", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DiffCodeLens { get; set; }

        /// <summary>
        /// Control the wrapping of the diff editor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("diffWordWrap", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? DiffWordWrap { get; set; }

        /// <summary>
        /// Allow the user to resize the diff editor split view.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enableSplitViewResizing", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? EnableSplitViewResizing { get; set; }

        /// <summary>
        /// Compute the diff by ignoring leading/trailing whitespace
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ignoreTrimWhitespace", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? IgnoreTrimWhitespace { get; set; }

        /// <summary>
        /// Is the diff editor inside another editor
        /// Defaults to false
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isInEmbeddedEditor", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? IsInEmbeddedEditor { get; set; }

        /// <summary>
        /// Timeout in milliseconds after which diff computation is cancelled.
        /// Defaults to 5000.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("maxComputationTime", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? MaxComputationTime { get; set; }

        /// <summary>
        /// Original model should be editable?
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("originalEditable", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? OriginalEditable { get; set; }

        /// <summary>
        /// Render +/- indicators for added/deleted changes.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("renderIndicators", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? RenderIndicators { get; set; }

        /// <summary>
        /// Is the diff editor should render overview ruler
        /// Defaults to true
        /// </summary>
        [Newtonsoft.Json.JsonProperty("renderOverviewRuler", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? RenderOverviewRuler { get; set; }

        /// <summary>
        /// Render the differences in two side-by-side editors.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("renderSideBySide", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? RenderSideBySide { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// (Serializable) View state for the diff editor.
    /// </summary>
    interface IDiffEditorViewState
    {
        [Newtonsoft.Json.JsonProperty("modified", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ICodeEditorViewState Modified { get; set; }

        [Newtonsoft.Json.JsonProperty("original", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ICodeEditorViewState Original { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Information about a line in the diff editor
    /// </summary>
    interface IDiffLineInformation
    {
        [Newtonsoft.Json.JsonProperty("equivalentLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double EquivalentLineNumber { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IDiffNavigator
    {
        bool CanNavigate();

        void Dispose();

        void Next();

        void Previous();

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IDiffNavigatorOptions
    {
        [Newtonsoft.Json.JsonProperty("alwaysRevealFirst", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AlwaysRevealFirst { get; set; }

        [Newtonsoft.Json.JsonProperty("followsCaret", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? FollowsCaret { get; set; }

        [Newtonsoft.Json.JsonProperty("ignoreCharChanges", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? IgnoreCharChanges { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IDimension
    {
        [Newtonsoft.Json.JsonProperty("height", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Height { get; set; }

        [Newtonsoft.Json.JsonProperty("width", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Width { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A builder and helper for edit operations for a command.
    /// </summary>
    interface IEditOperationBuilder
    {
        /// <summary>
        /// Add a new edit operation (a replace operation).
        /// </summary>
        void AddEditOperation(IRange range, string text, bool forceMoveMarkers);

        /// <summary>
        /// Add a new edit operation (a replace operation).
        /// The inverse edits will be accessible in `ICursorStateComputerData.getInverseEditOperations()`
        /// </summary>
        void AddTrackedEditOperation(IRange range, string text, bool forceMoveMarkers);

        /// <summary>
        /// Track `selection` when applying edit operations.
        /// A best effort will be made to not grow/expand the selection.
        /// An empty selection will clamp to a nearby character.
        /// </summary>
        /// <returns>
        /// A unique identifier.
        /// 
        /// </returns>
        string TrackSelection(Selection selection, bool trackPreviousOnEmpty);

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// An editor.
    /// </summary>
    interface IEditor
    {
        /// <summary>
        /// An event emitted when the editor has been disposed.
        /// </summary>
        event System.Action OnDidDispose;

        /// <summary>
        /// Dispose the editor.
        /// </summary>
        void Dispose();

        /// <summary>
        /// Brings browser focus to the editor text
        /// </summary>
        void Focus();

        /// <summary>
        /// Get the editor type. Please see `EditorType`.
        /// This is to avoid an instanceof check
        /// </summary>
        string GetEditorType();

        /// <summary>
        /// Get a unique id for this editor instance.
        /// </summary>
        string GetId();

        /// <summary>
        /// Gets the current model attached to this editor.
        /// </summary>
        IEditorModel GetModel();

        /// <summary>
        /// Returns the primary position of the cursor.
        /// </summary>
        Position GetPosition();

        /// <summary>
        /// Returns the primary selection of the editor.
        /// </summary>
        Selection GetSelection();

        /// <summary>
        /// Returns all the selections of the editor.
        /// </summary>
        Selection[] GetSelections();

        /// <summary>
        /// Returns all actions associated with this editor.
        /// </summary>
        IEditorAction[] GetSupportedActions();

        /// <summary>
        /// Given a position, returns a column number that takes tab-widths into account.
        /// </summary>
        double GetVisibleColumnFromPosition(IPosition position);

        /// <summary>
        /// Returns true if the text inside this editor is focused (i.e. cursor is blinking).
        /// </summary>
        bool HasTextFocus();

        /// <summary>
        /// Instructs the editor to remeasure its container. This method should
        /// be called when the container of the editor gets resized./// If a dimension is passed in, the passed in value will be used.
        /// 
        /// </summary>
        void Layout(IDimension dimension);

        /// <summary>
        /// Restores the view state of the editor from a serializable object generated by `saveViewState`.
        /// </summary>
        void RestoreViewState(IEditorViewState state);

        /// <summary>
        /// Scroll vertically as necessary and reveal a line.
        /// </summary>
        void RevealLine(double lineNumber, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically as necessary and reveal a line centered vertically.
        /// </summary>
        void RevealLineInCenter(double lineNumber, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically as necessary and reveal a line centered vertically only if it lies outside the viewport.
        /// </summary>
        void RevealLineInCenterIfOutsideViewport(double lineNumber, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically as necessary and reveal a line close to the top of the viewport,
        /// optimized for viewing a code definition.
        /// </summary>
        void RevealLineNearTop(double lineNumber, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically as necessary and reveal lines.
        /// </summary>
        void RevealLines(double startLineNumber, double endLineNumber, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically as necessary and reveal lines centered vertically.
        /// </summary>
        void RevealLinesInCenter(double lineNumber, double endLineNumber, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically as necessary and reveal lines centered vertically only if it lies outside the viewport.
        /// </summary>
        void RevealLinesInCenterIfOutsideViewport(double lineNumber, double endLineNumber, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically as necessary and reveal lines close to the top of the viewport,
        /// optimized for viewing a code definition.
        /// </summary>
        void RevealLinesNearTop(double lineNumber, double endLineNumber, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically or horizontally as necessary and reveal a position.
        /// </summary>
        void RevealPosition(IPosition position, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically or horizontally as necessary and reveal a position centered vertically.
        /// </summary>
        void RevealPositionInCenter(IPosition position, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically or horizontally as necessary and reveal a position centered vertically only if it lies outside the viewport.
        /// </summary>
        void RevealPositionInCenterIfOutsideViewport(IPosition position, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically or horizontally as necessary and reveal a position close to the top of the viewport,
        /// optimized for viewing a code definition.
        /// </summary>
        void RevealPositionNearTop(IPosition position, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically or horizontally as necessary and reveal a range.
        /// </summary>
        void RevealRange(IRange range, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically or horizontally as necessary and reveal a range at the top of the viewport.
        /// </summary>
        void RevealRangeAtTop(IRange range, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically or horizontally as necessary and reveal a range centered vertically.
        /// </summary>
        void RevealRangeInCenter(IRange range, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically or horizontally as necessary and reveal a range centered vertically only if it lies outside the viewport.
        /// </summary>
        void RevealRangeInCenterIfOutsideViewport(IRange range, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically or horizontally as necessary and reveal a range close to the top of the viewport,
        /// optimized for viewing a code definition.
        /// </summary>
        void RevealRangeNearTop(IRange range, ScrollType scrollType);

        /// <summary>
        /// Scroll vertically or horizontally as necessary and reveal a range close to the top of the viewport,
        /// optimized for viewing a code definition. Only if it lies outside the viewport.
        /// </summary>
        void RevealRangeNearTopIfOutsideViewport(IRange range, ScrollType scrollType);

        /// <summary>
        /// Saves current view state of the editor in a serializable object.
        /// </summary>
        IEditorViewState SaveViewState();

        /// <summary>
        /// Sets the current model attached to this editor.
        /// If the previous model was created by the editor via the value key in the options
        /// literal object, it will be destroyed. Otherwise, if the previous model was set
        /// via setModel, or the model key in the options literal object, the previous model
        /// will not be destroyed.
        /// It is safe to call setModel(null) to simply detach the current model from the editor.
        /// </summary>
        void SetModel(IEditorModel model);

        /// <summary>
        /// Set the primary position of the cursor. This will remove any secondary cursors.
        /// </summary>
        void SetPosition(IPosition position);

        /// <summary>
        /// Set the primary selection of the editor. This will remove any secondary cursors.
        /// </summary>
        void SetSelection(IRange selection);

        /// <summary>
        /// Set the primary selection of the editor. This will remove any secondary cursors.
        /// </summary>
        void SetSelection(Range selection);

        /// <summary>
        /// Set the primary selection of the editor. This will remove any secondary cursors.
        /// </summary>
        void SetSelection(ISelection selection);

        /// <summary>
        /// Set the primary selection of the editor. This will remove any secondary cursors.
        /// </summary>
        void SetSelection(Selection selection);

        /// <summary>
        /// Set the selections for all the cursors of the editor.
        /// Cursors will be removed or added, as necessary.
        /// </summary>
        void SetSelections(object selections);

        /// <summary>
        /// Directly trigger a handler or an editor action.
        /// </summary>
        void Trigger(string source, string handlerId, object payload);

        /// <summary>
        /// Update the editor's options after the editor has been created.
        /// </summary>
        void UpdateOptions(IEditorOptions newOptions);

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IEditorAction
    {
        [Newtonsoft.Json.JsonProperty("alias", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Alias { get; set; }

        [Newtonsoft.Json.JsonProperty("id", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("label", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Label { get; set; }

        bool IsSupported();

        System.Threading.Tasks.Task Run();

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for editor comments
    /// </summary>
    interface IEditorCommentsOptions
    {
        /// <summary>
        /// Ignore empty lines when inserting line comments.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ignoreEmptyLines", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? IgnoreEmptyLines { get; set; }

        /// <summary>
        /// Insert a space after the line comment token and inside the block comments tokens.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("insertSpace", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? InsertSpace { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IEditorConstructionOptions : IEditorOptions
    {
        /// <summary>
        /// The initial editor dimension (to avoid measuring the container).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dimension", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IDimension? Dimension { get; set; }

        /// <summary>
        /// Place overflow widgets inside an external DOM node.
        /// Defaults to an internal DOM node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("overflowWidgetsDomNode", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        HTMLElement? OverflowWidgetsDomNode { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// An editor contribution that gets created every time a new editor gets created and gets disposed when the editor gets disposed.
    /// </summary>
    interface IEditorContribution
    {
        /// <summary>
        /// Dispose this contribution.
        /// </summary>
        void Dispose();

        /// <summary>
        /// Restore view state.
        /// </summary>
        void RestoreViewState(object state);

        /// <summary>
        /// Store view state.
        /// </summary>
        object SaveViewState();

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for editor find widget
    /// </summary>
    interface IEditorFindOptions
    {
        [Newtonsoft.Json.JsonProperty("addExtraSpaceOnTop", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AddExtraSpaceOnTop { get; set; }

        /// <summary>
        /// Controls if Find in Selection flag is turned on in the editor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("autoFindInSelection", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AutoFindInSelection { get; set; }

        /// <summary>
        /// Controls whether the cursor should move to find matches while typing.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cursorMoveOnType", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? CursorMoveOnType { get; set; }

        /// <summary>
        /// Controls whether the search automatically restarts from the beginning (or the end) when no further matches can be found
        /// </summary>
        [Newtonsoft.Json.JsonProperty("loop", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Loop { get; set; }

        /// <summary>
        /// Controls if we seed search string in the Find Widget with editor selection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("seedSearchStringFromSelection", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SeedSearchStringFromSelection { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for editor hover
    /// </summary>
    interface IEditorHoverOptions
    {
        /// <summary>
        /// Delay for showing the hover.
        /// Defaults to 300.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("delay", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? Delay { get; set; }

        /// <summary>
        /// Enable the hover.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Enabled { get; set; }

        /// <summary>
        /// Is the hover sticky such that it can be clicked and its contents selected?
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sticky", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Sticky { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for editor inlineHints
    /// </summary>
    interface IEditorInlineHintsOptions
    {
        /// <summary>
        /// Enable the inline hints.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Enabled { get; set; }

        /// <summary>
        /// Font family of inline hints.
        /// Defaults to editor font family.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fontFamily", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? FontFamily { get; set; }

        /// <summary>
        /// Font size of inline hints.
        /// Default to 90% of the editor font size.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fontSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? FontSize { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for editor lightbulb
    /// </summary>
    interface IEditorLightbulbOptions
    {
        /// <summary>
        /// Enable the lightbulb code action.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Enabled { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for editor minimap
    /// </summary>
    interface IEditorMinimapOptions
    {
        /// <summary>
        /// Enable the rendering of the minimap.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Enabled { get; set; }

        /// <summary>
        /// Limit the width of the minimap to render at most a certain number of columns.
        /// Defaults to 120.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("maxColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? MaxColumn { get; set; }

        /// <summary>
        /// Render the actual text on a line (as opposed to color blocks).
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("renderCharacters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? RenderCharacters { get; set; }

        /// <summary>
        /// Relative size of the font in the minimap. Defaults to 1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scale", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? Scale { get; set; }

        /// <summary>
        /// Control the rendering of the minimap slider.
        /// Defaults to 'mouseover'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showSlider", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? ShowSlider { get; set; }

        /// <summary>
        /// Control the side of the minimap in editor.
        /// Defaults to 'right'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("side", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Side { get; set; }

        /// <summary>
        /// Control the minimap rendering mode.
        /// Defaults to 'actual'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("size", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Size { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A mouse event originating from the editor.
    /// </summary>
    interface IEditorMouseEvent
    {
        [Newtonsoft.Json.JsonProperty("event", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMouseEvent Event { get; set; }

        [Newtonsoft.Json.JsonProperty("target", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMouseTarget Target { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IEditorOption<K1, V>
    {
        [Newtonsoft.Json.JsonProperty("defaultValue", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        V DefaultValue { get; set; }

        [Newtonsoft.Json.JsonProperty("id", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        K1 Id { get; set; }

        [Newtonsoft.Json.JsonProperty("name", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Name { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for the editor.
    /// </summary>
    interface IEditorOptions
    {
        /// <summary>
        /// Accept suggestions on provider defined characters.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("acceptSuggestionOnCommitCharacter", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AcceptSuggestionOnCommitCharacter { get; set; }

        /// <summary>
        /// Accept suggestions on ENTER.
        /// Defaults to 'on'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("acceptSuggestionOnEnter", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AcceptSuggestionOnEnter { get; set; }

        /// <summary>
        /// Controls the number of lines in the editor that can be read out by a screen reader
        /// </summary>
        [Newtonsoft.Json.JsonProperty("accessibilityPageSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? AccessibilityPageSize { get; set; }

        /// <summary>
        /// Configure the editor's accessibility support.
        /// Defaults to 'auto'. It is best to leave this to 'auto'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("accessibilitySupport", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AccessibilitySupport { get; set; }

        /// <summary>
        /// The aria label for the editor's textarea (when it is focused).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ariaLabel", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AriaLabel { get; set; }

        /// <summary>
        /// Options for auto closing brackets.
        /// Defaults to language defined behavior.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("autoClosingBrackets", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        EditorAutoClosingStrategy? AutoClosingBrackets { get; set; }

        /// <summary>
        /// Options for typing over closing quotes or brackets.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("autoClosingOvertype", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        EditorAutoClosingOvertypeStrategy? AutoClosingOvertype { get; set; }

        /// <summary>
        /// Options for auto closing quotes.
        /// Defaults to language defined behavior.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("autoClosingQuotes", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        EditorAutoClosingStrategy? AutoClosingQuotes { get; set; }

        /// <summary>
        /// Controls whether the editor should automatically adjust the indentation when users type, paste, move or indent lines.
        /// Defaults to advanced.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("autoIndent", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AutoIndent { get; set; }

        /// <summary>
        /// Options for auto surrounding.
        /// Defaults to always allowing auto surrounding.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("autoSurround", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        EditorAutoSurroundStrategy? AutoSurround { get; set; }

        /// <summary>
        /// Enable that the editor will install an interval to check if its container dom node size has changed.
        /// Enabling this might have a severe performance impact.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("automaticLayout", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AutomaticLayout { get; set; }

        /// <summary>
        /// Timeout for running code actions on save.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("codeActionsOnSaveTimeout", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? CodeActionsOnSaveTimeout { get; set; }

        /// <summary>
        /// Show code lens
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("codeLens", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? CodeLens { get; set; }

        /// <summary>
        /// Code lens font family. Defaults to editor font family.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("codeLensFontFamily", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? CodeLensFontFamily { get; set; }

        /// <summary>
        /// Code lens font size. Default to 90% of the editor font size
        /// </summary>
        [Newtonsoft.Json.JsonProperty("codeLensFontSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? CodeLensFontSize { get; set; }

        /// <summary>
        /// Enable inline color decorators and color picker rendering.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("colorDecorators", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ColorDecorators { get; set; }

        /// <summary>
        /// Enable that the selection with the mouse and keys is doing column selection.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("columnSelection", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ColumnSelection { get; set; }

        /// <summary>
        /// Control the behaviour of comments in the editor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("comments", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEditorCommentsOptions? Comments { get; set; }

        /// <summary>
        /// Enable custom contextmenu.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("contextmenu", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Contextmenu { get; set; }

        /// <summary>
        /// Syntax highlighting is copied.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("copyWithSyntaxHighlighting", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? CopyWithSyntaxHighlighting { get; set; }

        /// <summary>
        /// Control the cursor animation style, possible values are 'blink', 'smooth', 'phase', 'expand' and 'solid'.
        /// Defaults to 'blink'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cursorBlinking", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? CursorBlinking { get; set; }

        /// <summary>
        /// Enable smooth caret animation.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cursorSmoothCaretAnimation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? CursorSmoothCaretAnimation { get; set; }

        /// <summary>
        /// Control the cursor style, either 'block' or 'line'.
        /// Defaults to 'line'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cursorStyle", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? CursorStyle { get; set; }

        /// <summary>
        /// Controls the minimal number of visible leading and trailing lines surrounding the cursor.
        /// Defaults to 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cursorSurroundingLines", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? CursorSurroundingLines { get; set; }

        /// <summary>
        /// Controls when `cursorSurroundingLines` should be enforced
        /// Defaults to `default`, `cursorSurroundingLines` is not enforced when cursor position is changed
        /// by mouse.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cursorSurroundingLinesStyle", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? CursorSurroundingLinesStyle { get; set; }

        /// <summary>
        /// Control the width of the cursor when cursorStyle is set to 'line'
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cursorWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? CursorWidth { get; set; }

        /// <summary>
        /// Controls whether the definition link opens element in the peek widget.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("definitionLinkOpensInPeek", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DefinitionLinkOpensInPeek { get; set; }

        /// <summary>
        /// Disable the use of `transform: translate3d(0px, 0px, 0px)` for the editor margin and lines layers.
        /// The usage of `transform: translate3d(0px, 0px, 0px)` acts as a hint for browsers to create an extra layer.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("disableLayerHinting", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DisableLayerHinting { get; set; }

        /// <summary>
        /// Disable the optimizations for monospace fonts.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("disableMonospaceOptimizations", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DisableMonospaceOptimizations { get; set; }

        /// <summary>
        /// Controls if the editor should allow to move selections via drag and drop.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dragAndDrop", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DragAndDrop { get; set; }

        /// <summary>
        /// Copying without a selection copies the current line.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("emptySelectionClipboard", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? EmptySelectionClipboard { get; set; }

        /// <summary>
        /// Class name to be added to the editor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("extraEditorClassName", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? ExtraEditorClassName { get; set; }

        /// <summary>
        /// FastScrolling mulitplier speed when pressing `Alt`
        /// Defaults to 5.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fastScrollSensitivity", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? FastScrollSensitivity { get; set; }

        /// <summary>
        /// Control the behavior of the find widget.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("find", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEditorFindOptions? Find { get; set; }

        /// <summary>
        /// Display overflow widgets as `fixed`.
        /// Defaults to `false`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fixedOverflowWidgets", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? FixedOverflowWidgets { get; set; }

        /// <summary>
        /// Enable code folding.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("folding", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Folding { get; set; }

        /// <summary>
        /// Enable highlight for folded regions.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("foldingHighlight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? FoldingHighlight { get; set; }

        /// <summary>
        /// Selects the folding strategy. 'auto' uses the strategies contributed for the current document, 'indentation' uses the indentation based folding strategy.
        /// Defaults to 'auto'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("foldingStrategy", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? FoldingStrategy { get; set; }

        /// <summary>
        /// The font family
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fontFamily", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? FontFamily { get; set; }

        /// <summary>
        /// Enable font ligatures.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fontLigatures", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? FontLigatures { get; set; }

        /// <summary>
        /// The font size
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fontSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? FontSize { get; set; }

        /// <summary>
        /// The font weight
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fontWeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? FontWeight { get; set; }

        /// <summary>
        /// Enable format on paste.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("formatOnPaste", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? FormatOnPaste { get; set; }

        /// <summary>
        /// Enable format on type.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("formatOnType", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? FormatOnType { get; set; }

        /// <summary>
        /// Enable the rendering of the glyph margin.
        /// Defaults to true in vscode and to false in monaco-editor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("glyphMargin", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? GlyphMargin { get; set; }

        /// <summary>
        
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gotoLocation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IGotoLocationOptions? GotoLocation { get; set; }

        /// <summary>
        /// Should the cursor be hidden in the overview ruler.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hideCursorInOverviewRuler", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? HideCursorInOverviewRuler { get; set; }

        /// <summary>
        /// Enable highlighting of the active indent guide.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("highlightActiveIndentGuide", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? HighlightActiveIndentGuide { get; set; }

        /// <summary>
        /// Configure the editor's hover.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hover", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEditorHoverOptions? Hover { get; set; }

        /// <summary>
        /// This editor is used inside a diff editor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("inDiffEditor", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? InDiffEditor { get; set; }

        /// <summary>
        /// Control the behavior and rendering of the inline hints.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("inlineHints", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEditorInlineHintsOptions? InlineHints { get; set; }

        /// <summary>
        /// The letter spacing
        /// </summary>
        [Newtonsoft.Json.JsonProperty("letterSpacing", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? LetterSpacing { get; set; }

        /// <summary>
        /// Control the behavior and rendering of the code action lightbulb.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lightbulb", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEditorLightbulbOptions? Lightbulb { get; set; }

        /// <summary>
        /// The width reserved for line decorations (in px).
        /// Line decorations are placed between line numbers and the editor content.
        /// You can pass in a string in the format floating point followed by "ch". e.g. 1.3ch.
        /// Defaults to 10.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lineDecorationsWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? LineDecorationsWidth { get; set; }

        /// <summary>
        /// The line height
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lineHeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? LineHeight { get; set; }

        /// <summary>
        /// Control the rendering of line numbers.
        /// If it is a function, it will be invoked when rendering a line number and the return value will be rendered.
        /// Otherwise, if it is a truey, line numbers will be rendered normally (equivalent of using an identity function).
        /// Otherwise, line numbers will not be rendered.
        /// Defaults to `on`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lineNumbers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        LineNumbersType? LineNumbers { get; set; }

        /// <summary>
        /// Control the width of line numbers, by reserving horizontal space for rendering at least an amount of digits.
        /// Defaults to 5.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lineNumbersMinChars", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? LineNumbersMinChars { get; set; }

        /// <summary>
        /// Enable linked editing.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("linkedEditing", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? LinkedEditing { get; set; }

        /// <summary>
        /// Enable detecting links and making them clickable.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("links", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Links { get; set; }

        /// <summary>
        /// Enable highlighting of matching brackets.
        /// Defaults to 'always'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("matchBrackets", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? MatchBrackets { get; set; }

        /// <summary>
        /// Control the behavior and rendering of the minimap.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("minimap", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEditorMinimapOptions? Minimap { get; set; }

        /// <summary>
        /// Control the mouse pointer style, either 'text' or 'default' or 'copy'
        /// Defaults to 'text'
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mouseStyle", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? MouseStyle { get; set; }

        /// <summary>
        /// A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.
        /// Defaults to 1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mouseWheelScrollSensitivity", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? MouseWheelScrollSensitivity { get; set; }

        /// <summary>
        /// Zoom the font in the editor when using the mouse wheel in combination with holding Ctrl.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mouseWheelZoom", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? MouseWheelZoom { get; set; }

        /// <summary>
        /// Merge overlapping selections.
        /// Defaults to true
        /// </summary>
        [Newtonsoft.Json.JsonProperty("multiCursorMergeOverlapping", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? MultiCursorMergeOverlapping { get; set; }

        /// <summary>
        /// The modifier to be used to add multiple cursors with the mouse.
        /// Defaults to 'alt'
        /// </summary>
        [Newtonsoft.Json.JsonProperty("multiCursorModifier", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? MultiCursorModifier { get; set; }

        /// <summary>
        /// Configure the behaviour when pasting a text with the line count equal to the cursor count.
        /// Defaults to 'spread'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("multiCursorPaste", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? MultiCursorPaste { get; set; }

        /// <summary>
        /// Enable semantic occurrences highlight.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("occurrencesHighlight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? OccurrencesHighlight { get; set; }

        /// <summary>
        /// Controls if a border should be drawn around the overview ruler.
        /// Defaults to `true`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("overviewRulerBorder", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? OverviewRulerBorder { get; set; }

        /// <summary>
        /// The number of vertical lanes the overview ruler should render.
        /// Defaults to 3.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("overviewRulerLanes", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? OverviewRulerLanes { get; set; }

        /// <summary>
        /// Controls the spacing around the editor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("padding", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEditorPaddingOptions? Padding { get; set; }

        /// <summary>
        /// Parameter hint options.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parameterHints", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEditorParameterHintOptions? ParameterHints { get; set; }

        /// <summary>
        /// Controls whether to focus the inline editor in the peek widget by default.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("peekWidgetDefaultFocus", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? PeekWidgetDefaultFocus { get; set; }

        /// <summary>
        /// Enable quick suggestions (shadow suggestions)
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("quickSuggestions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IQuickSuggestionsOptions? QuickSuggestions { get; set; }

        /// <summary>
        /// Quick suggestions show delay (in ms)
        /// Defaults to 10 (ms)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("quickSuggestionsDelay", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? QuickSuggestionsDelay { get; set; }

        /// <summary>
        /// Should the editor be read only.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("readOnly", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ReadOnly { get; set; }

        /// <summary>
        /// deprecated, use linkedEditing instead
        /// </summary>
        [Newtonsoft.Json.JsonProperty("renameOnType", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? RenameOnType { get; set; }

        /// <summary>
        /// Enable rendering of control characters.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("renderControlCharacters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? RenderControlCharacters { get; set; }

        /// <summary>
        /// Render last line number when the file ends with a newline.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("renderFinalNewline", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? RenderFinalNewline { get; set; }

        /// <summary>
        /// Enable rendering of indent guides.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("renderIndentGuides", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? RenderIndentGuides { get; set; }

        /// <summary>
        /// Enable rendering of current line highlight.
        /// Defaults to all.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("renderLineHighlight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? RenderLineHighlight { get; set; }

        /// <summary>
        /// Control if the current line highlight should be rendered only the editor is focused.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("renderLineHighlightOnlyWhenFocus", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? RenderLineHighlightOnlyWhenFocus { get; set; }

        /// <summary>
        /// Should the editor render validation decorations.
        /// Defaults to editable.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("renderValidationDecorations", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? RenderValidationDecorations { get; set; }

        /// <summary>
        /// Enable rendering of whitespace.
        /// Defaults to none.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("renderWhitespace", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? RenderWhitespace { get; set; }

        /// <summary>
        /// When revealing the cursor, a virtual padding (px) is added to the cursor, turning it into a rectangle.
        /// This virtual padding ensures that the cursor gets revealed before hitting the edge of the viewport.
        /// Defaults to 30 (px).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("revealHorizontalRightPadding", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? RevealHorizontalRightPadding { get; set; }

        /// <summary>
        /// Render the editor selection with rounded borders.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("roundedSelection", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? RoundedSelection { get; set; }

        /// <summary>
        /// Render vertical lines at the specified columns.
        /// Defaults to empty array.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rulers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRulerOption[]? Rulers { get; set; }

        /// <summary>
        /// Enable that scrolling can go beyond the last column by a number of columns.
        /// Defaults to 5.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scrollBeyondLastColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? ScrollBeyondLastColumn { get; set; }

        /// <summary>
        /// Enable that scrolling can go one screen size after the last line.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scrollBeyondLastLine", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ScrollBeyondLastLine { get; set; }

        /// <summary>
        /// Enable that the editor scrolls only the predominant axis. Prevents horizontal drift when scrolling vertically on a trackpad.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scrollPredominantAxis", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ScrollPredominantAxis { get; set; }

        /// <summary>
        /// Control the behavior and rendering of the scrollbars.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scrollbar", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEditorScrollbarOptions? Scrollbar { get; set; }

        /// <summary>
        /// Should the corresponding line be selected when clicking on the line number?
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectOnLineNumbers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SelectOnLineNumbers { get; set; }

        /// <summary>
        /// Enable Linux primary clipboard.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectionClipboard", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SelectionClipboard { get; set; }

        /// <summary>
        /// Enable selection highlight.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectionHighlight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SelectionHighlight { get; set; }

        /// <summary>
        /// Controls strikethrough deprecated variables.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showDeprecated", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowDeprecated { get; set; }

        /// <summary>
        /// Controls whether the fold actions in the gutter stay always visible or hide unless the mouse is over the gutter.
        /// Defaults to 'mouseover'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showFoldingControls", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? ShowFoldingControls { get; set; }

        /// <summary>
        /// Controls fading out of unused variables.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showUnused", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowUnused { get; set; }

        /// <summary>
        /// Smart select opptions;
        /// </summary>
        [Newtonsoft.Json.JsonProperty("smartSelect", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ISmartSelectOptions? SmartSelect { get; set; }

        /// <summary>
        /// Enable that the editor animates scrolling to a position.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("smoothScrolling", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SmoothScrolling { get; set; }

        /// <summary>
        /// Enable snippet suggestions. Default to 'true'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("snippetSuggestions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? SnippetSuggestions { get; set; }

        /// <summary>
        /// Emulate selection behaviour of tab characters when using spaces for indentation.
        /// This means selection will stick to tab stops.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stickyTabStops", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? StickyTabStops { get; set; }

        /// <summary>
        /// Performance guard: Stop rendering a line after x characters.
        /// Defaults to 10000.
        /// Use -1 to never stop rendering
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stopRenderingLineAfter", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? StopRenderingLineAfter { get; set; }

        /// <summary>
        /// Suggest options.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("suggest", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ISuggestOptions? Suggest { get; set; }

        /// <summary>
        /// The font size for the suggest widget.
        /// Defaults to the editor font size.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("suggestFontSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? SuggestFontSize { get; set; }

        /// <summary>
        /// The line height for the suggest widget.
        /// Defaults to the editor line height.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("suggestLineHeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? SuggestLineHeight { get; set; }

        /// <summary>
        /// Enable the suggestion box to pop-up on trigger characters.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("suggestOnTriggerCharacters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SuggestOnTriggerCharacters { get; set; }

        /// <summary>
        /// The history mode for suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("suggestSelection", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? SuggestSelection { get; set; }

        /// <summary>
        /// Enable tab completion.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tabCompletion", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? TabCompletion { get; set; }

        /// <summary>
        /// The `tabindex` property of the editor's textarea
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tabIndex", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? TabIndex { get; set; }

        /// <summary>
        /// Controls whether clicking on the empty content after a folded line will unfold the line.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("unfoldOnClickAfterEndOfLine", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? UnfoldOnClickAfterEndOfLine { get; set; }

        /// <summary>
        /// Remove unusual line terminators like LINE SEPARATOR (LS), PARAGRAPH SEPARATOR (PS).
        /// Defaults to 'prompt'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("unusualLineTerminators", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? UnusualLineTerminators { get; set; }

        /// <summary>
        /// Inserting and deleting whitespace follows tab stops.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("useTabStops", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? UseTabStops { get; set; }

        /// <summary>
        /// A string containing the word separators used when doing word navigation.
        /// Defaults to `~!@#$%^&amp;*()-=+[{]}\\|;:\'",.&lt;&gt;/?
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wordSeparators", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? WordSeparators { get; set; }

        /// <summary>
        /// Control the wrapping of the editor.
        /// When `wordWrap` = "off", the lines will never wrap.
        /// When `wordWrap` = "on", the lines will wrap at the viewport width.
        /// When `wordWrap` = "wordWrapColumn", the lines will wrap at `wordWrapColumn`.
        /// When `wordWrap` = "bounded", the lines will wrap at min(viewport width, wordWrapColumn).
        /// Defaults to "off".
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wordWrap", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? WordWrap { get; set; }

        /// <summary>
        /// Configure word wrapping characters. A break will be introduced after these characters.
        /// Defaults to ' \t})]?|/&amp;.,;'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wordWrapBreakAfterCharacters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? WordWrapBreakAfterCharacters { get; set; }

        /// <summary>
        /// Configure word wrapping characters. A break will be introduced before these characters.
        /// Defaults to '([{+'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wordWrapBreakBeforeCharacters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? WordWrapBreakBeforeCharacters { get; set; }

        /// <summary>
        /// Control the wrapping of the editor.
        /// When `wordWrap` = "off", the lines will never wrap.
        /// When `wordWrap` = "on", the lines will wrap at the viewport width.
        /// When `wordWrap` = "wordWrapColumn", the lines will wrap at `wordWrapColumn`.
        /// When `wordWrap` = "bounded", the lines will wrap at min(viewport width, wordWrapColumn).
        /// Defaults to 80.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wordWrapColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? WordWrapColumn { get; set; }

        /// <summary>
        /// Override the `wordWrap` setting.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wordWrapOverride1", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? WordWrapOverride1 { get; set; }

        /// <summary>
        /// Override the `wordWrapOverride1` setting.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wordWrapOverride2", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? WordWrapOverride2 { get; set; }

        /// <summary>
        /// Control indentation of wrapped lines. Can be: 'none', 'same', 'indent' or 'deepIndent'.
        /// Defaults to 'same' in vscode and to 'none' in monaco-editor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wrappingIndent", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? WrappingIndent { get; set; }

        /// <summary>
        /// Controls the wrapping strategy to use.
        /// Defaults to 'simple'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wrappingStrategy", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? WrappingStrategy { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IEditorOverrideServices
    {
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for editor padding
    /// </summary>
    interface IEditorPaddingOptions
    {
        /// <summary>
        /// Spacing between bottom edge of editor and last line.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bottom", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? Bottom { get; set; }

        /// <summary>
        /// Spacing between top edge of editor and first line.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("top", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? Top { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for parameter hints
    /// </summary>
    interface IEditorParameterHintOptions
    {
        /// <summary>
        /// Enable cycling of parameter hints.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cycle", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Cycle { get; set; }

        /// <summary>
        /// Enable parameter hints.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Enabled { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for editor scrollbars
    /// </summary>
    interface IEditorScrollbarOptions
    {
        /// <summary>
        /// Always consume mouse wheel events (always call preventDefault() and stopPropagation() on the browser events).
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("alwaysConsumeMouseWheel", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AlwaysConsumeMouseWheel { get; set; }

        /// <summary>
        /// The size of arrows (if displayed).
        /// Defaults to 11.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("arrowSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? ArrowSize { get; set; }

        /// <summary>
        /// Listen to mouse wheel events and react to them by scrolling.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("handleMouseWheel", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? HandleMouseWheel { get; set; }

        /// <summary>
        /// Render horizontal scrollbar.
        /// Defaults to 'auto'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("horizontal", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Horizontal { get; set; }

        /// <summary>
        /// Render arrows at the left and right of the horizontal scrollbar.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("horizontalHasArrows", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? HorizontalHasArrows { get; set; }

        /// <summary>
        /// Height in pixels for the horizontal scrollbar.
        /// Defaults to 10 (px).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("horizontalScrollbarSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? HorizontalScrollbarSize { get; set; }

        /// <summary>
        /// Height in pixels for the horizontal slider.
        /// Defaults to `horizontalScrollbarSize`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("horizontalSliderSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? HorizontalSliderSize { get; set; }

        /// <summary>
        /// Scroll gutter clicks move by page vs jump to position.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scrollByPage", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ScrollByPage { get; set; }

        /// <summary>
        /// Cast horizontal and vertical shadows when the content is scrolled.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("useShadows", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? UseShadows { get; set; }

        /// <summary>
        /// Render vertical scrollbar.
        /// Defaults to 'auto'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("vertical", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Vertical { get; set; }

        /// <summary>
        /// Render arrows at the top and bottom of the vertical scrollbar.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("verticalHasArrows", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? VerticalHasArrows { get; set; }

        /// <summary>
        /// Width in pixels for the vertical scrollbar.
        /// Defaults to 10 (px).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("verticalScrollbarSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? VerticalScrollbarSize { get; set; }

        /// <summary>
        /// Width in pixels for the vertical slider.
        /// Defaults to `verticalScrollbarSize`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("verticalSliderSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? VerticalSliderSize { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Options which apply for all editors.
    /// </summary>
    interface IGlobalEditorOptions
    {
        /// <summary>
        /// Controls whether `tabSize` and `insertSpaces` will be automatically detected when a file is opened based on the file contents.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("detectIndentation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DetectIndentation { get; set; }

        /// <summary>
        /// Insert spaces when pressing `Tab`.
        /// This setting is overridden based on the file contents when `detectIndentation` is on.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("insertSpaces", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? InsertSpaces { get; set; }

        /// <summary>
        /// Special handling for large files to disable certain memory intensive features.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("largeFileOptimizations", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? LargeFileOptimizations { get; set; }

        /// <summary>
        /// Lines above this length will not be tokenized for performance reasons.
        /// Defaults to 20000.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("maxTokenizationLineLength", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? MaxTokenizationLineLength { get; set; }

        /// <summary>
        /// Controls whether the semanticHighlighting is shown for the languages that support it.
        /// true: semanticHighlighting is enabled for all themes
        /// false: semanticHighlighting is disabled for all themes
        /// 'configuredByTheme': semanticHighlighting is controlled by the current color theme's semanticHighlighting setting.
        /// Defaults to 'byTheme'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("semanticHighlighting.enabled", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SemanticHighlighting.Enabled { get; set; }

        /// <summary>
        /// Keep peek editors open even when double clicking their content or when hitting `Escape`.
        /// Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stablePeek", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? StablePeek { get; set; }

        /// <summary>
        /// The number of spaces a tab is equal to.
        /// This setting is overridden based on the file contents when `detectIndentation` is on.
        /// Defaults to 4.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tabSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? TabSize { get; set; }

        /// <summary>
        /// Theme to be used for rendering.
        /// The current out-of-the-box available themes are: 'vs' (default), 'vs-dark', 'hc-black'.
        /// You can create custom themes via `monaco.editor.defineTheme`.
        /// To switch a theme, use `monaco.editor.setTheme`
        /// </summary>
        [Newtonsoft.Json.JsonProperty("theme", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Theme { get; set; }

        /// <summary>
        /// Remove trailing auto inserted whitespace.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("trimAutoWhitespace", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? TrimAutoWhitespace { get; set; }

        /// <summary>
        /// Controls whether completions should be computed based on words in the document.
        /// Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wordBasedSuggestions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? WordBasedSuggestions { get; set; }

        /// <summary>
        /// Controls whether word based completions should be included from opened documents of the same language or any language.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wordBasedSuggestionsOnlySameLanguage", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? WordBasedSuggestionsOnlySameLanguage { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for go to location
    /// </summary>
    interface IGotoLocationOptions
    {
        [Newtonsoft.Json.JsonProperty("alternativeDeclarationCommand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AlternativeDeclarationCommand { get; set; }

        [Newtonsoft.Json.JsonProperty("alternativeDefinitionCommand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AlternativeDefinitionCommand { get; set; }

        [Newtonsoft.Json.JsonProperty("alternativeImplementationCommand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AlternativeImplementationCommand { get; set; }

        [Newtonsoft.Json.JsonProperty("alternativeReferenceCommand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AlternativeReferenceCommand { get; set; }

        [Newtonsoft.Json.JsonProperty("alternativeTypeDefinitionCommand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AlternativeTypeDefinitionCommand { get; set; }

        [Newtonsoft.Json.JsonProperty("multiple", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        GoToLocationValues? Multiple { get; set; }

        [Newtonsoft.Json.JsonProperty("multipleDeclarations", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        GoToLocationValues? MultipleDeclarations { get; set; }

        [Newtonsoft.Json.JsonProperty("multipleDefinitions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        GoToLocationValues? MultipleDefinitions { get; set; }

        [Newtonsoft.Json.JsonProperty("multipleImplementations", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        GoToLocationValues? MultipleImplementations { get; set; }

        [Newtonsoft.Json.JsonProperty("multipleReferences", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        GoToLocationValues? MultipleReferences { get; set; }

        [Newtonsoft.Json.JsonProperty("multipleTypeDefinitions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        GoToLocationValues? MultipleTypeDefinitions { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A single edit operation, that has an identifier.
    /// </summary>
    interface IIdentifiedSingleEditOperation
    {
        /// <summary>
        /// This indicates that this operation has "insert" semantics.
        /// i.e. forceMoveMarkers = true =&gt; if `range` is collapsed, all markers at the position will be moved.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("forceMoveMarkers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ForceMoveMarkers { get; set; }

        /// <summary>
        /// The range to replace. This can be empty to emulate a simple insert.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

        /// <summary>
        /// The text to replace with. This can be null to emulate a simple delete.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("text", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Text { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A line change
    /// </summary>
    interface ILineChange : IChange
    {
        [Newtonsoft.Json.JsonProperty("charChanges", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ICharChange[] CharChanges { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IMarker
    {
        [Newtonsoft.Json.JsonProperty("code", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        TypedocConverter.GeneratedTypes.LiteralUriTargetStringValue? Code { get; set; }

        [Newtonsoft.Json.JsonProperty("endColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double EndColumn { get; set; }

        [Newtonsoft.Json.JsonProperty("endLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double EndLineNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("message", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Message { get; set; }

        [Newtonsoft.Json.JsonProperty("owner", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Owner { get; set; }

        [Newtonsoft.Json.JsonProperty("relatedInformation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRelatedInformation[]? RelatedInformation { get; set; }

        [Newtonsoft.Json.JsonProperty("resource", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri Resource { get; set; }

        [Newtonsoft.Json.JsonProperty("severity", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        MarkerSeverity Severity { get; set; }

        [Newtonsoft.Json.JsonProperty("source", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Source { get; set; }

        [Newtonsoft.Json.JsonProperty("startColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double StartColumn { get; set; }

        [Newtonsoft.Json.JsonProperty("startLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double StartLineNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("tags", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        MarkerTag[]? Tags { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A structure defining a problem/warning/etc.
    /// </summary>
    interface IMarkerData
    {
        [Newtonsoft.Json.JsonProperty("code", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        TypedocConverter.GeneratedTypes.LiteralUriTargetStringValue? Code { get; set; }

        [Newtonsoft.Json.JsonProperty("endColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double EndColumn { get; set; }

        [Newtonsoft.Json.JsonProperty("endLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double EndLineNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("message", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Message { get; set; }

        [Newtonsoft.Json.JsonProperty("relatedInformation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRelatedInformation[]? RelatedInformation { get; set; }

        [Newtonsoft.Json.JsonProperty("severity", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        MarkerSeverity Severity { get; set; }

        [Newtonsoft.Json.JsonProperty("source", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Source { get; set; }

        [Newtonsoft.Json.JsonProperty("startColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double StartColumn { get; set; }

        [Newtonsoft.Json.JsonProperty("startLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double StartLineNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("tags", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        MarkerTag[]? Tags { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// An event describing that an editor has had its model reset (i.e. `editor.setModel()`).
    /// </summary>
    interface IModelChangedEvent
    {
        /// <summary>
        /// The `uri` of the new model or null.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("newModelUrl", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri NewModelUrl { get; set; }

        /// <summary>
        /// The `uri` of the previous model or null.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("oldModelUrl", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri OldModelUrl { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IModelContentChange
    {
        /// <summary>
        /// The range that got replaced.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

        /// <summary>
        /// The length of the range that got replaced.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rangeLength", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double RangeLength { get; set; }

        /// <summary>
        /// The offset of the range that got replaced.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rangeOffset", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double RangeOffset { get; set; }

        /// <summary>
        /// The new text for the range.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("text", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Text { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// An event describing a change in the text of a model.
    /// </summary>
    interface IModelContentChangedEvent
    {
        [Newtonsoft.Json.JsonProperty("changes", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IModelContentChange[] Changes { get; set; }

        /// <summary>
        /// The (new) end-of-line character.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("eol", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Eol { get; set; }

        /// <summary>
        /// Flag that indicates that all decorations were lost with this edit.
        /// The model has been reset to a new value.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isFlush", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IsFlush { get; set; }

        /// <summary>
        /// Flag that indicates that this event was generated while redoing.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isRedoing", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IsRedoing { get; set; }

        /// <summary>
        /// Flag that indicates that this event was generated while undoing.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isUndoing", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IsUndoing { get; set; }

        /// <summary>
        /// The new version id the model has transitioned to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("versionId", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double VersionId { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A decoration in the model.
    /// </summary>
    interface IModelDecoration
    {
        /// <summary>
        /// Identifier for a decoration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Id { get; set; }

        /// <summary>
        /// Options associated with this decoration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("options", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IModelDecorationOptions Options { get; set; }

        /// <summary>
        /// Identifier for a decoration's owner.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ownerId", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double OwnerId { get; set; }

        /// <summary>
        /// Range that this decoration covers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Range Range { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Options for rendering a model decoration in the overview ruler.
    /// </summary>
    interface IModelDecorationMinimapOptions : IDecorationOptions
    {
        /// <summary>
        /// The position in the overview ruler.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("position", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        MinimapPosition Position { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Options for a model decoration.
    /// </summary>
    interface IModelDecorationOptions
    {
        /// <summary>
        /// If set, the decoration will be rendered after the text with this CSS class name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("afterContentClassName", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AfterContentClassName { get; set; }

        /// <summary>
        /// If set, the decoration will be rendered before the text with this CSS class name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("beforeContentClassName", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? BeforeContentClassName { get; set; }

        /// <summary>
        /// CSS class name describing the decoration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("className", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? ClassName { get; set; }

        /// <summary>
        /// If set, the decoration will be rendered in the lines decorations with this CSS class name, but only for the first line in case of line wrapping.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("firstLineDecorationClassName", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? FirstLineDecorationClassName { get; set; }

        /// <summary>
        /// If set, the decoration will be rendered in the glyph margin with this CSS class name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("glyphMarginClassName", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? GlyphMarginClassName { get; set; }

        /// <summary>
        /// Message to be rendered when hovering over the glyph margin decoration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("glyphMarginHoverMessage", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMarkdownString[]? GlyphMarginHoverMessage { get; set; }

        /// <summary>
        /// Array of MarkdownString to render as the decoration message.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hoverMessage", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMarkdownString[]? HoverMessage { get; set; }

        /// <summary>
        /// If set, the decoration will be rendered inline with the text with this CSS class name.
        /// Please use this only for CSS rules that must impact the text. For example, use `className`
        /// to have a background color decoration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("inlineClassName", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? InlineClassName { get; set; }

        /// <summary>
        /// If there is an `inlineClassName` which affects letter spacing.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("inlineClassNameAffectsLetterSpacing", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? InlineClassNameAffectsLetterSpacing { get; set; }

        /// <summary>
        /// Should the decoration expand to encompass a whole line.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isWholeLine", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? IsWholeLine { get; set; }

        /// <summary>
        /// If set, the decoration will be rendered in the lines decorations with this CSS class name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("linesDecorationsClassName", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? LinesDecorationsClassName { get; set; }

        /// <summary>
        /// If set, the decoration will be rendered in the margin (covering its full width) with this CSS class name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("marginClassName", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? MarginClassName { get; set; }

        /// <summary>
        /// If set, render this decoration in the minimap.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("minimap", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IModelDecorationMinimapOptions? Minimap { get; set; }

        /// <summary>
        /// If set, render this decoration in the overview ruler.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("overviewRuler", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IModelDecorationOverviewRulerOptions? OverviewRuler { get; set; }

        /// <summary>
        /// Customize the growing behavior of the decoration when typing at the edges of the decoration.
        /// Defaults to TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stickiness", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        TrackedRangeStickiness? Stickiness { get; set; }

        /// <summary>
        /// Specifies the stack order of a decoration.
        /// A decoration with greater stack order is always in front of a decoration with a lower stack order.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("zIndex", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? ZIndex { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Options for rendering a model decoration in the overview ruler.
    /// </summary>
    interface IModelDecorationOverviewRulerOptions : IDecorationOptions
    {
        /// <summary>
        /// The position in the overview ruler.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("position", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        OverviewRulerLane Position { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// An event describing that model decorations have changed.
    /// </summary>
    interface IModelDecorationsChangedEvent
    {
        [Newtonsoft.Json.JsonProperty("affectsMinimap", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool AffectsMinimap { get; set; }

        [Newtonsoft.Json.JsonProperty("affectsOverviewRuler", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool AffectsOverviewRuler { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// New model decorations.
    /// </summary>
    interface IModelDeltaDecoration
    {
        /// <summary>
        /// Options associated with this decoration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("options", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IModelDecorationOptions Options { get; set; }

        /// <summary>
        /// Range that this decoration covers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// An event describing that the current mode associated with a model has changed.
    /// </summary>
    interface IModelLanguageChangedEvent
    {
        /// <summary>
        /// New language
        /// </summary>
        [Newtonsoft.Json.JsonProperty("newLanguage", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string NewLanguage { get; set; }

        /// <summary>
        /// Previous language
        /// </summary>
        [Newtonsoft.Json.JsonProperty("oldLanguage", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string OldLanguage { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// An event describing that the language configuration associated with a model has changed.
    /// </summary>
    interface IModelLanguageConfigurationChangedEvent
    {
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IModelOptionsChangedEvent
    {
        [Newtonsoft.Json.JsonProperty("indentSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IndentSize { get; set; }

        [Newtonsoft.Json.JsonProperty("insertSpaces", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool InsertSpaces { get; set; }

        [Newtonsoft.Json.JsonProperty("tabSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool TabSize { get; set; }

        [Newtonsoft.Json.JsonProperty("trimAutoWhitespace", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool TrimAutoWhitespace { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Target hit with the mouse in the editor.
    /// </summary>
    interface IMouseTarget
    {
        /// <summary>
        /// Some extra detail.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("detail", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object Detail { get; set; }

        /// <summary>
        /// The target element
        /// </summary>
        [Newtonsoft.Json.JsonProperty("element", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Element Element { get; set; }

        /// <summary>
        /// Desired mouse column (e.g. when position.column gets clamped to text length -- clicking after text on a line).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mouseColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double MouseColumn { get; set; }

        /// <summary>
        /// The 'approximate' editor position
        /// </summary>
        [Newtonsoft.Json.JsonProperty("position", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Position Position { get; set; }

        /// <summary>
        /// The 'approximate' editor range
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Range Range { get; set; }

        /// <summary>
        /// The target type
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        MouseTargetType Type { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface INewScrollPosition
    {
        [Newtonsoft.Json.JsonProperty("scrollLeft", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? ScrollLeft { get; set; }

        [Newtonsoft.Json.JsonProperty("scrollTop", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? ScrollTop { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// An overlay widgets renders on top of the text.
    /// </summary>
    interface IOverlayWidget
    {
        /// <summary>
        /// Get the dom node of the overlay widget.
        /// </summary>
        HTMLElement GetDomNode();

        /// <summary>
        /// Get a unique identifier of the overlay widget.
        /// </summary>
        string GetId();

        /// <summary>
        /// Get the placement of the overlay widget.
        /// If null is returned, the overlay widget is responsible to place itself.
        /// </summary>
        IOverlayWidgetPosition GetPosition();

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A position for rendering overlay widgets.
    /// </summary>
    interface IOverlayWidgetPosition
    {
        /// <summary>
        /// The position preference for the overlay widget.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("preference", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        OverlayWidgetPositionPreference Preference { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IPartialEditorMouseEvent
    {
        [Newtonsoft.Json.JsonProperty("event", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMouseEvent Event { get; set; }

        [Newtonsoft.Json.JsonProperty("target", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMouseTarget Target { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A paste event originating from the editor.
    /// </summary>
    interface IPasteEvent
    {
        [Newtonsoft.Json.JsonProperty("mode", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Mode { get; set; }

        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Range Range { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for quick suggestions
    /// </summary>
    interface IQuickSuggestionsOptions
    {
        [Newtonsoft.Json.JsonProperty("comments", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Comments { get; set; }

        [Newtonsoft.Json.JsonProperty("other", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Other { get; set; }

        [Newtonsoft.Json.JsonProperty("strings", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Strings { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    
    /// </summary>
    interface IRelatedInformation
    {
        [Newtonsoft.Json.JsonProperty("endColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double EndColumn { get; set; }

        [Newtonsoft.Json.JsonProperty("endLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double EndLineNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("message", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Message { get; set; }

        [Newtonsoft.Json.JsonProperty("resource", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri Resource { get; set; }

        [Newtonsoft.Json.JsonProperty("startColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double StartColumn { get; set; }

        [Newtonsoft.Json.JsonProperty("startLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double StartLineNumber { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IRulerOption
    {
        [Newtonsoft.Json.JsonProperty("color", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Color { get; set; }

        [Newtonsoft.Json.JsonProperty("column", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Column { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A single edit operation, that acts as a simple replace.
    /// i.e. Replace text at `range` with `text` in model.
    /// </summary>
    interface ISingleEditOperation
    {
        /// <summary>
        /// This indicates that this operation has "insert" semantics.
        /// i.e. forceMoveMarkers = true =&gt; if `range` is collapsed, all markers at the position will be moved.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("forceMoveMarkers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ForceMoveMarkers { get; set; }

        /// <summary>
        /// The range to replace. This can be empty to emulate a simple insert.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

        /// <summary>
        /// The text to replace with. This can be null to emulate a simple delete.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("text", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Text { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface ISmartSelectOptions
    {
        [Newtonsoft.Json.JsonProperty("selectLeadingAndTrailingWhitespace", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SelectLeadingAndTrailingWhitespace { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IStandaloneCodeEditor : ICodeEditor
    {
        IDisposable AddAction(IActionDescriptor descriptor);

        string AddCommand(double keybinding, ICommandHandler handler, string context);

        IContextKey<T> CreateContextKey<T>(string key, T defaultValue);

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IStandaloneDiffEditor : IDiffEditor
    {
        IDisposable AddAction(IActionDescriptor descriptor);

        string AddCommand(double keybinding, ICommandHandler handler, string context);

        IContextKey<T> CreateContextKey<T>(string key, T defaultValue);

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The options to create an editor.
    /// </summary>
    interface IStandaloneEditorConstructionOptions : IEditorConstructionOptions, IGlobalEditorOptions
    {
        /// <summary>
        /// An URL to open when Ctrl+H (Windows and Linux) or Cmd+H (OSX) is pressed in
        /// the accessibility help dialog in the editor./// Defaults to "https://go.microsoft.com/fwlink/?linkid=852450"
        /// 
        /// </summary>
        [Newtonsoft.Json.JsonProperty("accessibilityHelpUrl", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AccessibilityHelpUrl { get; set; }

        /// <summary>
        /// The initial language of the auto created model in the editor.
        /// To not create automatically a model, use `model: null`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("language", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Language { get; set; }

        /// <summary>
        /// The initial model associated with this code editor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("model", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ITextModel? Model { get; set; }

        /// <summary>
        /// The initial value of the auto created model in the editor.
        /// To not create automatically a model, use `model: null`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Value { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IStandaloneThemeData
    {
        [Newtonsoft.Json.JsonProperty("base", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        BuiltinTheme Base { get; set; }

        [Newtonsoft.Json.JsonProperty("colors", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IColors Colors { get; set; }

        [Newtonsoft.Json.JsonProperty("encodedTokensColors", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? EncodedTokensColors { get; set; }

        [Newtonsoft.Json.JsonProperty("inherit", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool Inherit { get; set; }

        [Newtonsoft.Json.JsonProperty("rules", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ITokenThemeRule[] Rules { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for editor suggest widget
    /// </summary>
    interface ISuggestOptions
    {
        /// <summary>
        /// Enable graceful matching. Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("filterGraceful", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? FilterGraceful { get; set; }

        /// <summary>
        /// Overwrite word ends on accept. Default to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("insertMode", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? InsertMode { get; set; }

        /// <summary>
        /// Favours words that appear close to the cursor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("localityBonus", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? LocalityBonus { get; set; }

        /// <summary>
        /// Enable using global storage for remembering suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("shareSuggestSelections", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShareSuggestSelections { get; set; }

        /// <summary>
        /// Show class-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showClasses", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowClasses { get; set; }

        /// <summary>
        /// Show color-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showColors", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowColors { get; set; }

        /// <summary>
        /// Show constant-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showConstants", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowConstants { get; set; }

        /// <summary>
        /// Show constructor-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showConstructors", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowConstructors { get; set; }

        /// <summary>
        /// Show enumMember-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showEnumMembers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowEnumMembers { get; set; }

        /// <summary>
        /// Show enum-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showEnums", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowEnums { get; set; }

        /// <summary>
        /// Show event-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showEvents", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowEvents { get; set; }

        /// <summary>
        /// Show field-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showFields", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowFields { get; set; }

        /// <summary>
        /// Show file-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showFiles", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowFiles { get; set; }

        /// <summary>
        /// Show folder-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showFolders", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowFolders { get; set; }

        /// <summary>
        /// Show function-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showFunctions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowFunctions { get; set; }

        /// <summary>
        /// Enable or disable icons in suggestions. Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showIcons", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowIcons { get; set; }

        /// <summary>
        /// Show details inline with the label. Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showInlineDetails", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowInlineDetails { get; set; }

        /// <summary>
        /// Show interface-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showInterfaces", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowInterfaces { get; set; }

        /// <summary>
        /// Show issue-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showIssues", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowIssues { get; set; }

        /// <summary>
        /// Show keyword-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showKeywords", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowKeywords { get; set; }

        /// <summary>
        /// Show method-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showMethods", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowMethods { get; set; }

        /// <summary>
        /// Show module-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showModules", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowModules { get; set; }

        /// <summary>
        /// Show operator-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showOperators", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowOperators { get; set; }

        /// <summary>
        /// Show property-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showProperties", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowProperties { get; set; }

        /// <summary>
        /// Show reference-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showReferences", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowReferences { get; set; }

        /// <summary>
        /// Show snippet-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showSnippets", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowSnippets { get; set; }

        /// <summary>
        /// Enable or disable the suggest status bar.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showStatusBar", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowStatusBar { get; set; }

        /// <summary>
        /// Show struct-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showStructs", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowStructs { get; set; }

        /// <summary>
        /// Show typeParameter-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showTypeParameters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowTypeParameters { get; set; }

        /// <summary>
        /// Show unit-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showUnits", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowUnits { get; set; }

        /// <summary>
        /// Show user-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showUsers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowUsers { get; set; }

        /// <summary>
        /// Show value-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showValues", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowValues { get; set; }

        /// <summary>
        /// Show variable-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showVariables", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowVariables { get; set; }

        /// <summary>
        /// Show text-suggestions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("showWords", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ShowWords { get; set; }

        /// <summary>
        /// Prevent quick suggestions when a snippet is active. Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("snippetsPreventQuickSuggestions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SnippetsPreventQuickSuggestions { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A model.
    /// </summary>
    interface ITextModel
    {
        /// <summary>
        /// An event emitted when the contents of the model have changed.
        /// </summary>
        event System.Action<IModelContentChangedEvent> OnDidChangeContent;

        /// <summary>
        /// An event emitted when decorations of the model have changed.
        /// </summary>
        event System.Action<IModelDecorationsChangedEvent> OnDidChangeDecorations;

        /// <summary>
        /// An event emitted when the language associated with the model has changed.
        /// </summary>
        event System.Action<IModelLanguageChangedEvent> OnDidChangeLanguage;

        /// <summary>
        /// An event emitted when the language configuration associated with the model has changed.
        /// </summary>
        event System.Action<IModelLanguageConfigurationChangedEvent> OnDidChangeLanguageConfiguration;

        /// <summary>
        /// An event emitted when the model options have changed.
        /// </summary>
        event System.Action<IModelOptionsChangedEvent> OnDidChangeOptions;

        /// <summary>
        /// An event emitted right before disposing the model.
        /// </summary>
        event System.Action OnWillDispose;

        /// <summary>
        /// A unique identifier associated with this model.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Id { get; set; }

        /// <summary>
        /// Gets the resource associated with this editor model.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("uri", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri Uri { get; set; }

        /// <summary>
        /// Edit the model without adding the edits to the undo stack.
        /// This can have dire consequences on the undo stack! See @pushEditOperations for the preferred way.
        /// </summary>
        /// <returns>
        /// If desired, the inverse edit operations, that, when applied, will bring the model back to the previous state.
        /// 
        /// </returns>
        void ApplyEdits(IIdentifiedSingleEditOperation[] operations);

        void ApplyEdits(IIdentifiedSingleEditOperation[] operations, string computeUndoEdits);

        IValidEditOperation[] ApplyEdits(IIdentifiedSingleEditOperation[] operations, string computeUndoEdits);

        /// <summary>
        /// Perform a minimum amount of operations, in order to transform the decorations
        /// identified by `oldDecorations` to the decorations described by `newDecorations`
        /// and returns the new identifiers associated with the resulting decorations.
        /// </summary>
        /// <returns>
        /// An array containing the new decorations identifiers.
        /// 
        /// </returns>
        string[] DeltaDecorations(string[] oldDecorations, IModelDeltaDecoration[] newDecorations, double ownerId);

        /// <summary>
        /// Detect the indentation options for this model from its content.
        /// </summary>
        void DetectIndentation(bool defaultInsertSpaces, double defaultTabSize);

        /// <summary>
        /// Destroy this model. This will unbind the model from the mode
        /// and make all necessary clean-up to release this object to the GC.
        /// </summary>
        void Dispose();

        /// <summary>
        /// Search the model.
        /// </summary>
        /// <returns>
        /// The ranges where the matches are. It is empty if not matches have been found.
        /// 
        /// </returns>
        FindMatch[] FindMatches(string searchString, bool searchOnlyEditableRange, bool isRegex, bool matchCase, string wordSeparators, bool captureMatches, double limitResultCount);

        /// <summary>
        /// Search the model.
        /// </summary>
        /// <returns>
        /// The ranges where the matches are. It is empty if no matches have been found.
        /// 
        /// </returns>
        FindMatch[] FindMatches(string searchString, IRange[] searchScope, bool isRegex, bool matchCase, string wordSeparators, bool captureMatches, double limitResultCount);

        /// <summary>
        /// Search the model for the next match. Loops to the beginning of the model if needed.
        /// </summary>
        /// <returns>
        /// The range where the next match is. It is null if no next match has been found.
        /// 
        /// </returns>
        FindMatch FindNextMatch(string searchString, IPosition searchStart, bool isRegex, bool matchCase, string wordSeparators, bool captureMatches);

        /// <summary>
        /// Search the model for the previous match. Loops to the end of the model if needed.
        /// </summary>
        /// <returns>
        /// The range where the previous match is. It is null if no previous match has been found.
        /// 
        /// </returns>
        FindMatch FindPreviousMatch(string searchString, IPosition searchStart, bool isRegex, bool matchCase, string wordSeparators, bool captureMatches);

        /// <summary>
        /// Gets all the decorations as an array.
        /// </summary>
        IModelDecoration[] GetAllDecorations(double ownerId, bool filterOutValidation);

        /// <summary>
        /// Get the alternative version id of the model.
        /// This alternative version id is not always incremented,
        /// it will return the same values in the case of undo-redo.
        /// </summary>
        double GetAlternativeVersionId();

        /// <summary>
        /// Get the character count of text in a certain range.
        /// </summary>
        double GetCharacterCountInRange(IRange range);

        /// <summary>
        /// Get the options associated with a decoration.
        /// </summary>
        /// <returns>
        /// The decoration options or null if the decoration was not found.
        /// 
        /// </returns>
        IModelDecorationOptions GetDecorationOptions(string id);

        /// <summary>
        /// Get the range associated with a decoration.
        /// </summary>
        /// <returns>
        /// The decoration range or null if the decoration was not found.
        /// 
        /// </returns>
        Range GetDecorationRange(string id);

        /// <summary>
        /// Gets all the decorations in a range as an array. Only `startLineNumber` and `endLineNumber` from `range` are used for filtering.
        /// So for now it returns all the decorations on the same line as `range`.
        /// </summary>
        /// <returns>
        /// An array with the decorations
        /// 
        /// </returns>
        IModelDecoration[] GetDecorationsInRange(IRange range, double ownerId, bool filterOutValidation);

        /// <summary>
        /// Get the end of line sequence predominantly used in the text buffer.
        /// </summary>
        /// <returns>
        /// EOL char sequence (e.g.: '\n' or '\r\n').
        /// 
        /// </returns>
        string GetEOL();

        /// <summary>
        /// Get the end of line sequence predominantly used in the text buffer.
        /// </summary>
        EndOfLineSequence GetEndOfLineSequence();

        /// <summary>
        /// Get a range covering the entire model
        /// </summary>
        Range GetFullModelRange();

        /// <summary>
        /// Get the text for a certain line.
        /// </summary>
        string GetLineContent(double lineNumber);

        /// <summary>
        /// Get the number of lines in the model.
        /// </summary>
        double GetLineCount();

        /// <summary>
        /// Gets all the decorations for the line `lineNumber` as an array.
        /// </summary>
        /// <returns>
        /// An array with the decorations
        /// 
        /// </returns>
        IModelDecoration[] GetLineDecorations(double lineNumber, double ownerId, bool filterOutValidation);

        /// <summary>
        /// Returns the column before the first non whitespace character for line at `lineNumber`.
        /// Returns 0 if line is empty or contains only whitespace.
        /// </summary>
        double GetLineFirstNonWhitespaceColumn(double lineNumber);

        /// <summary>
        /// Returns the column after the last non whitespace character for line at `lineNumber`.
        /// Returns 0 if line is empty or contains only whitespace.
        /// </summary>
        double GetLineLastNonWhitespaceColumn(double lineNumber);

        /// <summary>
        /// Get the text length for a certain line.
        /// </summary>
        double GetLineLength(double lineNumber);

        /// <summary>
        /// Get the maximum legal column for line at `lineNumber`
        /// </summary>
        double GetLineMaxColumn(double lineNumber);

        /// <summary>
        /// Get the minimum legal column for line at `lineNumber`
        /// </summary>
        double GetLineMinColumn(double lineNumber);

        /// <summary>
        /// Get the text for all lines.
        /// </summary>
        string[] GetLinesContent();

        /// <summary>
        /// Gets all the decorations for the lines between `startLineNumber` and `endLineNumber` as an array.
        /// </summary>
        /// <returns>
        /// An array with the decorations
        /// 
        /// </returns>
        IModelDecoration[] GetLinesDecorations(double startLineNumber, double endLineNumber, double ownerId, bool filterOutValidation);

        /// <summary>
        /// Get the language associated with this model.
        /// </summary>
        string GetModeId();

        /// <summary>
        /// Converts the position to a zero-based offset./// The position will be [adjusted](#TextDocument.validatePosition).
        /// 
        /// </summary>
        /// <returns>
        /// A valid zero-based offset.
        /// 
        /// </returns>
        double GetOffsetAt(IPosition position);

        /// <summary>
        /// Get the resolved options for this model.
        /// </summary>
        TextModelResolvedOptions GetOptions();

        /// <summary>
        /// Gets all the decorations that should be rendered in the overview ruler as an array.
        /// </summary>
        IModelDecoration[] GetOverviewRulerDecorations(double ownerId, bool filterOutValidation);

        /// <summary>
        /// Converts a zero-based offset to a position.
        /// </summary>
        /// <returns>
        /// A valid [position](#Position).
        /// 
        /// </returns>
        Position GetPositionAt(double offset);

        /// <summary>
        /// Get the text stored in this model.
        /// </summary>
        /// <returns>
        /// The text.
        /// 
        /// </returns>
        string GetValue(EndOfLinePreference eol, bool preserveBOM);

        /// <summary>
        /// Get the text in a certain range.
        /// </summary>
        /// <returns>
        /// The text.
        /// 
        /// </returns>
        string GetValueInRange(IRange range, EndOfLinePreference eol);

        /// <summary>
        /// Get the length of the text stored in this model.
        /// </summary>
        double GetValueLength(EndOfLinePreference eol, bool preserveBOM);

        /// <summary>
        /// Get the length of text in a certain range.
        /// </summary>
        /// <returns>
        /// The text length.
        /// 
        /// </returns>
        double GetValueLengthInRange(IRange range);

        /// <summary>
        /// Get the current version id of the model.
        /// Anytime a change happens to the model (even undo/redo),
        /// the version id is incremented.
        /// </summary>
        double GetVersionId();

        /// <summary>
        /// Get the word under or besides `position`.
        /// </summary>
        /// <returns>
        /// The word under or besides `position`. Might be null.
        /// 
        /// </returns>
        IWordAtPosition GetWordAtPosition(IPosition position);

        /// <summary>
        /// Get the word under or besides `position` trimmed to `position`.column
        /// </summary>
        /// <returns>
        /// The word under or besides `position`. Will never be null.
        /// 
        /// </returns>
        IWordAtPosition GetWordUntilPosition(IPosition position);

        /// <summary>
        /// Returns if the model was disposed or not.
        /// </summary>
        bool IsDisposed();

        /// <summary>
        /// Advances the given position by the given offset (negative offsets are also accepted)
        /// and returns it as a new valid position./// If the offset and position are such that their combination goes beyond the beginning or
        /// end of the model, throws an exception.
        /// 
        /// If the offset is such that the new position would be in the middle of a multi-byte
        /// line terminator, throws an exception.
        /// 
        /// </summary>
        Position ModifyPosition(IPosition position, double offset);

        /// <summary>
        /// Normalize a string containing whitespace according to indentation rules (converts to spaces or to tabs).
        /// </summary>
        string NormalizeIndentation(string str);

        /// <summary>
        /// Open the current undo-redo element.
        /// This offers a way to remove the current undo/redo stop point.
        /// </summary>
        void PopStackElement();

        /// <summary>
        /// Change the end of line sequence. This is the preferred way of
        /// changing the eol sequence. This will land on the undo stack.
        /// </summary>
        void PushEOL(EndOfLineSequence eol);

        /// <summary>
        /// Push edit operations, basically editing the model. This is the preferred way
        /// of editing the model. The edit operations will land on the undo stack.
        /// </summary>
        /// <returns>
        /// The cursor state returned by the `cursorStateComputer`.
        /// 
        /// </returns>
        Selection[] PushEditOperations(Selection[] beforeCursorState, IIdentifiedSingleEditOperation[] editOperations, ICursorStateComputer cursorStateComputer);

        /// <summary>
        /// Close the current undo-redo element.
        /// This offers a way to create an undo/redo stop point.
        /// </summary>
        void PushStackElement();

        /// <summary>
        /// Change the end of line sequence without recording in the undo stack.
        /// This can have dire consequences on the undo stack! See @pushEOL for the preferred way.
        /// </summary>
        void SetEOL(EndOfLineSequence eol);

        /// <summary>
        /// Replace the entire text buffer value contained in this model.
        /// </summary>
        void SetValue(string newValue);

        /// <summary>
        /// Change the options of this model.
        /// </summary>
        void UpdateOptions(ITextModelUpdateOptions newOpts);

        /// <summary>
        /// Create a valid position,
        /// </summary>
        Position ValidatePosition(IPosition position);

        /// <summary>
        /// Create a valid range.
        /// </summary>
        Range ValidateRange(IRange range);

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface ITextModelUpdateOptions
    {
        [Newtonsoft.Json.JsonProperty("indentSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? IndentSize { get; set; }

        [Newtonsoft.Json.JsonProperty("insertSpaces", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? InsertSpaces { get; set; }

        [Newtonsoft.Json.JsonProperty("tabSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? TabSize { get; set; }

        [Newtonsoft.Json.JsonProperty("trimAutoWhitespace", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? TrimAutoWhitespace { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface ITokenThemeRule
    {
        [Newtonsoft.Json.JsonProperty("background", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Background { get; set; }

        [Newtonsoft.Json.JsonProperty("fontStyle", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? FontStyle { get; set; }

        [Newtonsoft.Json.JsonProperty("foreground", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Foreground { get; set; }

        [Newtonsoft.Json.JsonProperty("token", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Token { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IValidEditOperation
    {
        /// <summary>
        /// The range to replace. This can be empty to emulate a simple insert.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Range Range { get; set; }

        /// <summary>
        /// The text to replace with. This can be empty to emulate a simple delete.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("text", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Text { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A (serializable) state of the view.
    /// </summary>
    interface IViewState
    {
        [Newtonsoft.Json.JsonProperty("firstPosition", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IPosition FirstPosition { get; set; }

        [Newtonsoft.Json.JsonProperty("firstPositionDeltaTop", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double FirstPositionDeltaTop { get; set; }

        [Newtonsoft.Json.JsonProperty("scrollLeft", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ScrollLeft { get; set; }

        /// <summary>
        /// written by previous versions
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scrollTop", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? ScrollTop { get; set; }

        /// <summary>
        /// written by previous versions
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scrollTopWithoutViewZones", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? ScrollTopWithoutViewZones { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A view zone is a full horizontal rectangle that 'pushes' text down.
    /// The editor reserves space for view zones when rendering.
    /// </summary>
    interface IViewZone
    {
        /// <summary>
        /// The column after which this zone should appear.
        /// If not set, the maxLineColumn of `afterLineNumber` will be used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("afterColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? AfterColumn { get; set; }

        /// <summary>
        /// The line number after which this zone should appear.
        /// Use 0 to place a view zone before the first line number.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("afterLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double AfterLineNumber { get; set; }

        /// <summary>
        /// The dom node of the view zone
        /// </summary>
        [Newtonsoft.Json.JsonProperty("domNode", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        HTMLElement DomNode { get; set; }

        /// <summary>
        /// The height in lines of the view zone.
        /// If specified, `heightInPx` will be used instead of this.
        /// If neither `heightInPx` nor `heightInLines` is specified, a default of `heightInLines` = 1 will be chosen.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("heightInLines", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? HeightInLines { get; set; }

        /// <summary>
        /// The height in px of the view zone.
        /// If this is set, the editor will give preference to it rather than `heightInLines` above.
        /// If neither `heightInPx` nor `heightInLines` is specified, a default of `heightInLines` = 1 will be chosen.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("heightInPx", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? HeightInPx { get; set; }

        /// <summary>
        /// An optional dom node for the view zone that will be placed in the margin area.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("marginDomNode", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        HTMLElement? MarginDomNode { get; set; }

        /// <summary>
        /// The minimum width in px of the view zone.
        /// If this is set, the editor will ensure that the scroll width is &gt;= than this value.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("minWidthInPx", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? MinWidthInPx { get; set; }

        /// <summary>
        /// Callback which gives the height in pixels of the view zone.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("onComputedHeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        System.Action<double>? OnComputedHeight { get; set; }

        /// <summary>
        /// Callback which gives the relative top of the view zone as it appears (taking scrolling into account).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("onDomNodeTop", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        System.Action<double>? OnDomNodeTop { get; set; }

        /// <summary>
        /// Suppress mouse down events.
        /// If set, the editor will attach a mouse down listener to the view zone and .preventDefault on it.
        /// Defaults to false
        /// </summary>
        [Newtonsoft.Json.JsonProperty("suppressMouseDown", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SuppressMouseDown { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// An accessor that allows for zones to be added or removed.
    /// </summary>
    interface IViewZoneChangeAccessor
    {
        /// <summary>
        /// Create a new view zone.
        /// </summary>
        /// <returns>
        /// A unique identifier to the view zone.
        /// 
        /// </returns>
        string AddZone(IViewZone zone);

        /// <summary>
        /// Change a zone's position.
        /// The editor will rescan the `afterLineNumber` and `afterColumn` properties of a view zone.
        /// </summary>
        void LayoutZone(string id);

        /// <summary>
        /// Remove a zone
        /// </summary>
        void RemoveZone(string id);

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IWebWorkerOptions
    {
        /// <summary>
        /// The data to send over when calling create on the module.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("createData", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object? CreateData { get; set; }

        /// <summary>
        /// An object that can be used by the web worker to make calls back to the main thread.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("host", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object? Host { get; set; }

        /// <summary>
        /// Keep idle models.
        /// Defaults to false, which means that idle models will stop syncing after a while.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("keepIdleModels", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? KeepIdleModels { get; set; }

        /// <summary>
        /// A label to be used to identify the web worker for debugging purposes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("label", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Label { get; set; }

        /// <summary>
        /// The AMD moduleId to load.
        /// It should export a function `create` that should return the exported proxy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("moduleId", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string ModuleId { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Word inside a model.
    /// </summary>
    interface IWordAtPosition
    {
        /// <summary>
        /// The column where the word ends.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double EndColumn { get; set; }

        /// <summary>
        /// The column where the word starts.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double StartColumn { get; set; }

        /// <summary>
        /// The word.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("word", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Word { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface InternalEditorPaddingOptions
    {
        [Newtonsoft.Json.JsonProperty("bottom", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Bottom { get; set; }

        [Newtonsoft.Json.JsonProperty("top", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Top { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface InternalEditorRenderLineNumbersOptions
    {
        [Newtonsoft.Json.JsonProperty("renderFn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        System.Func<double, string> RenderFn { get; set; }

        [Newtonsoft.Json.JsonProperty("renderType", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        RenderLineNumbersType RenderType { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface InternalEditorScrollbarOptions
    {
        [Newtonsoft.Json.JsonProperty("alwaysConsumeMouseWheel", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool AlwaysConsumeMouseWheel { get; set; }

        [Newtonsoft.Json.JsonProperty("arrowSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ArrowSize { get; set; }

        [Newtonsoft.Json.JsonProperty("handleMouseWheel", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool HandleMouseWheel { get; set; }

        [Newtonsoft.Json.JsonProperty("horizontal", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ScrollbarVisibility Horizontal { get; set; }

        [Newtonsoft.Json.JsonProperty("horizontalHasArrows", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool HorizontalHasArrows { get; set; }

        [Newtonsoft.Json.JsonProperty("horizontalScrollbarSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double HorizontalScrollbarSize { get; set; }

        [Newtonsoft.Json.JsonProperty("horizontalSliderSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double HorizontalSliderSize { get; set; }

        [Newtonsoft.Json.JsonProperty("scrollByPage", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool ScrollByPage { get; set; }

        [Newtonsoft.Json.JsonProperty("useShadows", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool UseShadows { get; set; }

        [Newtonsoft.Json.JsonProperty("vertical", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ScrollbarVisibility Vertical { get; set; }

        [Newtonsoft.Json.JsonProperty("verticalHasArrows", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool VerticalHasArrows { get; set; }

        [Newtonsoft.Json.JsonProperty("verticalScrollbarSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double VerticalScrollbarSize { get; set; }

        [Newtonsoft.Json.JsonProperty("verticalSliderSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double VerticalSliderSize { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A web worker that can provide a proxy to an arbitrary file.
    /// </summary>
    interface MonacoWebWorker<T>
    {
        /// <summary>
        /// Terminate the web worker, thus invalidating the returned proxy.
        /// </summary>
        void Dispose();

        /// <summary>
        /// Get a proxy to the arbitrary loaded code.
        /// </summary>
        System.Threading.Tasks.Task<T> GetProxy();

        /// <summary>
        /// Synchronize (send) the models at `resources` to the web worker,
        /// making them available in the monaco.worker.getMirrorModels().
        /// </summary>
        System.Threading.Tasks.Task<T> WithSyncedResources(Uri[] resources);

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A description for the overview ruler position.
    /// </summary>
    interface OverviewRulerPosition
    {
        /// <summary>
        /// Height of the overview ruler
        /// </summary>
        [Newtonsoft.Json.JsonProperty("height", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Height { get; set; }

        /// <summary>
        /// Right position for the overview ruler
        /// </summary>
        [Newtonsoft.Json.JsonProperty("right", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Right { get; set; }

        /// <summary>
        /// Top position for the overview ruler
        /// </summary>
        [Newtonsoft.Json.JsonProperty("top", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Top { get; set; }

        /// <summary>
        /// Width of the overview ruler
        /// </summary>
        [Newtonsoft.Json.JsonProperty("width", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Width { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface ThemeColor
    {
        [Newtonsoft.Json.JsonProperty("id", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Id { get; set; }

    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    [Newtonsoft.Json.JsonConverter(typeof(BuiltinThemeConverter))]
    enum BuiltinTheme
    {
        ///<summary>
        /// vs
        ///</summary>
        Vs,
        ///<summary>
        /// vs-dark
        ///</summary>
        VsDark,
        ///<summary>
        /// hc-black
        ///</summary>
        HcBlack
    }

    class BuiltinThemeConverter : Newtonsoft.Json.JsonConverter
    {
        public override bool CanConvert(System.Type t) => t == typeof(BuiltinTheme) || t == typeof(BuiltinTheme?);

        public override object ReadJson(Newtonsoft.Json.JsonReader reader, System.Type t, object? existingValue, Newtonsoft.Json.JsonSerializer serializer)
            => reader.TokenType switch
            {
                Newtonsoft.Json.JsonToken.String =>
                    serializer.Deserialize<string>(reader) switch
                    {
                        "vs" => BuiltinTheme.Vs,
                        "vs-dark" => BuiltinTheme.VsDark,
                        "hc-black" => BuiltinTheme.HcBlack,
                        _ => throw new System.NotSupportedException("Cannot unmarshal type BuiltinTheme")
                    },
                _ => throw new System.NotSupportedException("Cannot unmarshal type BuiltinTheme")
            };

        public override void WriteJson(Newtonsoft.Json.JsonWriter writer, object? untypedValue, Newtonsoft.Json.JsonSerializer serializer)
        {
            if (untypedValue is null) { serializer.Serialize(writer, null); return; }
            var value = (BuiltinTheme)untypedValue;
            switch (value)
            {
                case BuiltinTheme.Vs: serializer.Serialize(writer, "vs"); return;
                case BuiltinTheme.VsDark: serializer.Serialize(writer, "vs-dark"); return;
                case BuiltinTheme.HcBlack: serializer.Serialize(writer, "hc-black"); return;
                default: break;
            }
            throw new System.NotSupportedException("Cannot marshal type BuiltinTheme");
        }
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for typing over closing quotes or brackets
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(EditorAutoClosingOvertypeStrategyConverter))]
    enum EditorAutoClosingOvertypeStrategy
    {
        ///<summary>
        /// always
        ///</summary>
        Always,
        ///<summary>
        /// auto
        ///</summary>
        Auto,
        ///<summary>
        /// never
        ///</summary>
        Never
    }

    class EditorAutoClosingOvertypeStrategyConverter : Newtonsoft.Json.JsonConverter
    {
        public override bool CanConvert(System.Type t) => t == typeof(EditorAutoClosingOvertypeStrategy) || t == typeof(EditorAutoClosingOvertypeStrategy?);

        public override object ReadJson(Newtonsoft.Json.JsonReader reader, System.Type t, object? existingValue, Newtonsoft.Json.JsonSerializer serializer)
            => reader.TokenType switch
            {
                Newtonsoft.Json.JsonToken.String =>
                    serializer.Deserialize<string>(reader) switch
                    {
                        "always" => EditorAutoClosingOvertypeStrategy.Always,
                        "auto" => EditorAutoClosingOvertypeStrategy.Auto,
                        "never" => EditorAutoClosingOvertypeStrategy.Never,
                        _ => throw new System.NotSupportedException("Cannot unmarshal type EditorAutoClosingOvertypeStrategy")
                    },
                _ => throw new System.NotSupportedException("Cannot unmarshal type EditorAutoClosingOvertypeStrategy")
            };

        public override void WriteJson(Newtonsoft.Json.JsonWriter writer, object? untypedValue, Newtonsoft.Json.JsonSerializer serializer)
        {
            if (untypedValue is null) { serializer.Serialize(writer, null); return; }
            var value = (EditorAutoClosingOvertypeStrategy)untypedValue;
            switch (value)
            {
                case EditorAutoClosingOvertypeStrategy.Always: serializer.Serialize(writer, "always"); return;
                case EditorAutoClosingOvertypeStrategy.Auto: serializer.Serialize(writer, "auto"); return;
                case EditorAutoClosingOvertypeStrategy.Never: serializer.Serialize(writer, "never"); return;
                default: break;
            }
            throw new System.NotSupportedException("Cannot marshal type EditorAutoClosingOvertypeStrategy");
        }
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for auto closing quotes and brackets
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(EditorAutoClosingStrategyConverter))]
    enum EditorAutoClosingStrategy
    {
        ///<summary>
        /// always
        ///</summary>
        Always,
        ///<summary>
        /// languageDefined
        ///</summary>
        LanguageDefined,
        ///<summary>
        /// beforeWhitespace
        ///</summary>
        BeforeWhitespace,
        ///<summary>
        /// never
        ///</summary>
        Never
    }

    class EditorAutoClosingStrategyConverter : Newtonsoft.Json.JsonConverter
    {
        public override bool CanConvert(System.Type t) => t == typeof(EditorAutoClosingStrategy) || t == typeof(EditorAutoClosingStrategy?);

        public override object ReadJson(Newtonsoft.Json.JsonReader reader, System.Type t, object? existingValue, Newtonsoft.Json.JsonSerializer serializer)
            => reader.TokenType switch
            {
                Newtonsoft.Json.JsonToken.String =>
                    serializer.Deserialize<string>(reader) switch
                    {
                        "always" => EditorAutoClosingStrategy.Always,
                        "languageDefined" => EditorAutoClosingStrategy.LanguageDefined,
                        "beforeWhitespace" => EditorAutoClosingStrategy.BeforeWhitespace,
                        "never" => EditorAutoClosingStrategy.Never,
                        _ => throw new System.NotSupportedException("Cannot unmarshal type EditorAutoClosingStrategy")
                    },
                _ => throw new System.NotSupportedException("Cannot unmarshal type EditorAutoClosingStrategy")
            };

        public override void WriteJson(Newtonsoft.Json.JsonWriter writer, object? untypedValue, Newtonsoft.Json.JsonSerializer serializer)
        {
            if (untypedValue is null) { serializer.Serialize(writer, null); return; }
            var value = (EditorAutoClosingStrategy)untypedValue;
            switch (value)
            {
                case EditorAutoClosingStrategy.Always: serializer.Serialize(writer, "always"); return;
                case EditorAutoClosingStrategy.LanguageDefined: serializer.Serialize(writer, "languageDefined"); return;
                case EditorAutoClosingStrategy.BeforeWhitespace: serializer.Serialize(writer, "beforeWhitespace"); return;
                case EditorAutoClosingStrategy.Never: serializer.Serialize(writer, "never"); return;
                default: break;
            }
            throw new System.NotSupportedException("Cannot marshal type EditorAutoClosingStrategy");
        }
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Configuration options for auto wrapping quotes and brackets
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(EditorAutoSurroundStrategyConverter))]
    enum EditorAutoSurroundStrategy
    {
        ///<summary>
        /// languageDefined
        ///</summary>
        LanguageDefined,
        ///<summary>
        /// quotes
        ///</summary>
        Quotes,
        ///<summary>
        /// brackets
        ///</summary>
        Brackets,
        ///<summary>
        /// never
        ///</summary>
        Never
    }

    class EditorAutoSurroundStrategyConverter : Newtonsoft.Json.JsonConverter
    {
        public override bool CanConvert(System.Type t) => t == typeof(EditorAutoSurroundStrategy) || t == typeof(EditorAutoSurroundStrategy?);

        public override object ReadJson(Newtonsoft.Json.JsonReader reader, System.Type t, object? existingValue, Newtonsoft.Json.JsonSerializer serializer)
            => reader.TokenType switch
            {
                Newtonsoft.Json.JsonToken.String =>
                    serializer.Deserialize<string>(reader) switch
                    {
                        "languageDefined" => EditorAutoSurroundStrategy.LanguageDefined,
                        "quotes" => EditorAutoSurroundStrategy.Quotes,
                        "brackets" => EditorAutoSurroundStrategy.Brackets,
                        "never" => EditorAutoSurroundStrategy.Never,
                        _ => throw new System.NotSupportedException("Cannot unmarshal type EditorAutoSurroundStrategy")
                    },
                _ => throw new System.NotSupportedException("Cannot unmarshal type EditorAutoSurroundStrategy")
            };

        public override void WriteJson(Newtonsoft.Json.JsonWriter writer, object? untypedValue, Newtonsoft.Json.JsonSerializer serializer)
        {
            if (untypedValue is null) { serializer.Serialize(writer, null); return; }
            var value = (EditorAutoSurroundStrategy)untypedValue;
            switch (value)
            {
                case EditorAutoSurroundStrategy.LanguageDefined: serializer.Serialize(writer, "languageDefined"); return;
                case EditorAutoSurroundStrategy.Quotes: serializer.Serialize(writer, "quotes"); return;
                case EditorAutoSurroundStrategy.Brackets: serializer.Serialize(writer, "brackets"); return;
                case EditorAutoSurroundStrategy.Never: serializer.Serialize(writer, "never"); return;
                default: break;
            }
            throw new System.NotSupportedException("Cannot marshal type EditorAutoSurroundStrategy");
        }
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    [Newtonsoft.Json.JsonConverter(typeof(GoToLocationValuesConverter))]
    enum GoToLocationValues
    {
        ///<summary>
        /// peek
        ///</summary>
        Peek,
        ///<summary>
        /// gotoAndPeek
        ///</summary>
        GotoAndPeek,
        ///<summary>
        /// goto
        ///</summary>
        Goto
    }

    class GoToLocationValuesConverter : Newtonsoft.Json.JsonConverter
    {
        public override bool CanConvert(System.Type t) => t == typeof(GoToLocationValues) || t == typeof(GoToLocationValues?);

        public override object ReadJson(Newtonsoft.Json.JsonReader reader, System.Type t, object? existingValue, Newtonsoft.Json.JsonSerializer serializer)
            => reader.TokenType switch
            {
                Newtonsoft.Json.JsonToken.String =>
                    serializer.Deserialize<string>(reader) switch
                    {
                        "peek" => GoToLocationValues.Peek,
                        "gotoAndPeek" => GoToLocationValues.GotoAndPeek,
                        "goto" => GoToLocationValues.Goto,
                        _ => throw new System.NotSupportedException("Cannot unmarshal type GoToLocationValues")
                    },
                _ => throw new System.NotSupportedException("Cannot unmarshal type GoToLocationValues")
            };

        public override void WriteJson(Newtonsoft.Json.JsonWriter writer, object? untypedValue, Newtonsoft.Json.JsonSerializer serializer)
        {
            if (untypedValue is null) { serializer.Serialize(writer, null); return; }
            var value = (GoToLocationValues)untypedValue;
            switch (value)
            {
                case GoToLocationValues.Peek: serializer.Serialize(writer, "peek"); return;
                case GoToLocationValues.GotoAndPeek: serializer.Serialize(writer, "gotoAndPeek"); return;
                case GoToLocationValues.Goto: serializer.Serialize(writer, "goto"); return;
                default: break;
            }
            throw new System.NotSupportedException("Cannot marshal type GoToLocationValues");
        }
    }
}

namespace Monaco.Editor
{
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    [Newtonsoft.Json.JsonConverter(typeof(LineNumbersTypeConverter))]
    enum LineNumbersType
    {
        ///<summary>
        /// on
        ///</summary>
        On,
        ///<summary>
        /// off
        ///</summary>
        Off,
        ///<summary>
        /// relative
        ///</summary>
        Relative,
        ///<summary>
        /// interval
        ///</summary>
        Interval
    }

    class LineNumbersTypeConverter : Newtonsoft.Json.JsonConverter
    {
        public override bool CanConvert(System.Type t) => t == typeof(LineNumbersType) || t == typeof(LineNumbersType?);

        public override object ReadJson(Newtonsoft.Json.JsonReader reader, System.Type t, object? existingValue, Newtonsoft.Json.JsonSerializer serializer)
            => reader.TokenType switch
            {
                Newtonsoft.Json.JsonToken.String =>
                    serializer.Deserialize<string>(reader) switch
                    {
                        "on" => LineNumbersType.On,
                        "off" => LineNumbersType.Off,
                        "relative" => LineNumbersType.Relative,
                        "interval" => LineNumbersType.Interval,
                        _ => throw new System.NotSupportedException("Cannot unmarshal type LineNumbersType")
                    },
                _ => throw new System.NotSupportedException("Cannot unmarshal type LineNumbersType")
            };

        public override void WriteJson(Newtonsoft.Json.JsonWriter writer, object? untypedValue, Newtonsoft.Json.JsonSerializer serializer)
        {
            if (untypedValue is null) { serializer.Serialize(writer, null); return; }
            var value = (LineNumbersType)untypedValue;
            switch (value)
            {
                case LineNumbersType.On: serializer.Serialize(writer, "on"); return;
                case LineNumbersType.Off: serializer.Serialize(writer, "off"); return;
                case LineNumbersType.Relative: serializer.Serialize(writer, "relative"); return;
                case LineNumbersType.Interval: serializer.Serialize(writer, "interval"); return;
                default: break;
            }
            throw new System.NotSupportedException("Cannot marshal type LineNumbersType");
        }
    }
}

namespace Monaco.Languages.Css
{
    using Monaco.Editor;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface DiagnosticsOptions
    {
        [Newtonsoft.Json.JsonProperty("lint", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        TypedocConverter.GeneratedTypes.LiteralUnionStringStringStringArgumentsInColorFunctionUnionStringStringStringBoxModelUnionStringStringStringCompatibleVendorPrefixesUnionStringStringStringDuplicatePropertiesUnionStringStringStringEmptyRulesUnionStringStringStringFloatUnionStringStringStringFontFacePropertiesUnionStringStringStringHexColorLengthUnionStringStringStringIdSelectorUnionStringStringStringIeHackUnionStringStringStringImportStatementUnionStringStringStringImportantUnionStringStringStringPropertyIgnoredDueToDisplayUnionStringStringStringUniversalSelectorUnionStringStringStringUnknownPropertiesUnionStringStringStringUnknownVendorSpecificPropertiesUnionStringStringStringVendorPrefixUnionStringStringStringZeroUnits? Lint { get; set; }

        [Newtonsoft.Json.JsonProperty("validate", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Validate { get; set; }

    }
}

namespace Monaco.Languages.Css
{
    using Monaco.Editor;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface LanguageServiceDefaults
    {
        [Newtonsoft.Json.JsonProperty("diagnosticsOptions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        DiagnosticsOptions DiagnosticsOptions { get; set; }

        [Newtonsoft.Json.JsonProperty("languageId", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string LanguageId { get; set; }

        [Newtonsoft.Json.JsonProperty("modeConfiguration", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ModeConfiguration ModeConfiguration { get; set; }

        [Newtonsoft.Json.JsonProperty("onDidChange", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEvent<LanguageServiceDefaults> OnDidChange { get; set; }

        void SetDiagnosticsOptions(DiagnosticsOptions options);

        void SetModeConfiguration(ModeConfiguration modeConfiguration);

    }
}

namespace Monaco.Languages.Css
{
    using Monaco.Editor;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface ModeConfiguration
    {
        /// <summary>
        /// Defines whether the built-in color provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("colors", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Colors { get; set; }

        /// <summary>
        /// Defines whether the built-in completionItemProvider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("completionItems", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? CompletionItems { get; set; }

        /// <summary>
        /// Defines whether the built-in definitions provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("definitions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Definitions { get; set; }

        /// <summary>
        /// Defines whether the built-in diagnostic provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("diagnostics", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Diagnostics { get; set; }

        /// <summary>
        /// Defines whether the built-in references provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentHighlights", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DocumentHighlights { get; set; }

        /// <summary>
        /// Defines whether the built-in documentSymbolProvider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentSymbols", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DocumentSymbols { get; set; }

        /// <summary>
        /// Defines whether the built-in foldingRange provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("foldingRanges", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? FoldingRanges { get; set; }

        /// <summary>
        /// Defines whether the built-in hoverProvider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hovers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Hovers { get; set; }

        /// <summary>
        /// Defines whether the built-in references provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("references", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? References { get; set; }

        /// <summary>
        /// Defines whether the built-in rename provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rename", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Rename { get; set; }

        /// <summary>
        /// Defines whether the built-in selection range provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectionRanges", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SelectionRanges { get; set; }

    }
}

namespace Monaco.Languages.Html
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface CompletionConfiguration
    {
    }
}

namespace Monaco.Languages.Html
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface HTMLFormatConfiguration
    {
        [Newtonsoft.Json.JsonProperty("contentUnformatted", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string ContentUnformatted { get; set; }

        [Newtonsoft.Json.JsonProperty("endWithNewline", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool EndWithNewline { get; set; }

        [Newtonsoft.Json.JsonProperty("extraLiners", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string ExtraLiners { get; set; }

        [Newtonsoft.Json.JsonProperty("indentHandlebars", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IndentHandlebars { get; set; }

        [Newtonsoft.Json.JsonProperty("indentInnerHtml", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IndentInnerHtml { get; set; }

        [Newtonsoft.Json.JsonProperty("insertSpaces", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool InsertSpaces { get; set; }

        [Newtonsoft.Json.JsonProperty("maxPreserveNewLines", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double MaxPreserveNewLines { get; set; }

        [Newtonsoft.Json.JsonProperty("preserveNewLines", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool PreserveNewLines { get; set; }

        [Newtonsoft.Json.JsonProperty("tabSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double TabSize { get; set; }

        [Newtonsoft.Json.JsonProperty("unformatted", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Unformatted { get; set; }

        [Newtonsoft.Json.JsonProperty("wrapAttributes", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string WrapAttributes { get; set; }

        [Newtonsoft.Json.JsonProperty("wrapLineLength", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double WrapLineLength { get; set; }

    }
}

namespace Monaco.Languages.Html
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface LanguageServiceDefaults
    {
        [Newtonsoft.Json.JsonProperty("languageId", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string LanguageId { get; set; }

        [Newtonsoft.Json.JsonProperty("modeConfiguration", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ModeConfiguration ModeConfiguration { get; set; }

        [Newtonsoft.Json.JsonProperty("onDidChange", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEvent<LanguageServiceDefaults> OnDidChange { get; set; }

        [Newtonsoft.Json.JsonProperty("options", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Options Options { get; set; }

        void SetOptions(Options options);

    }
}

namespace Monaco.Languages.Html
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface ModeConfiguration
    {
        /// <summary>
        /// Defines whether the built-in color provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("colors", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Colors { get; set; }

        /// <summary>
        /// Defines whether the built-in completionItemProvider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("completionItems", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? CompletionItems { get; set; }

        /// <summary>
        /// Defines whether the built-in diagnostic provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("diagnostics", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Diagnostics { get; set; }

        /// <summary>
        /// Defines whether the built-in documentFormattingEdit provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentFormattingEdits", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DocumentFormattingEdits { get; set; }

        /// <summary>
        /// Defines whether the built-in references provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentHighlights", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DocumentHighlights { get; set; }

        /// <summary>
        /// Defines whether the built-in documentRangeFormattingEdit provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentRangeFormattingEdits", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DocumentRangeFormattingEdits { get; set; }

        /// <summary>
        /// Defines whether the built-in documentSymbolProvider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentSymbols", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DocumentSymbols { get; set; }

        /// <summary>
        /// Defines whether the built-in foldingRange provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("foldingRanges", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? FoldingRanges { get; set; }

        /// <summary>
        /// Defines whether the built-in hoverProvider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hovers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Hovers { get; set; }

        /// <summary>
        /// Defines whether the built-in definitions provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("links", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Links { get; set; }

        /// <summary>
        /// Defines whether the built-in rename provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rename", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Rename { get; set; }

        /// <summary>
        /// Defines whether the built-in selection range provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectionRanges", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SelectionRanges { get; set; }

    }
}

namespace Monaco.Languages.Html
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface Options
    {
        /// <summary>
        /// If set, comments are tolerated. If set to false, syntax errors will be emitted for comments.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("format", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        HTMLFormatConfiguration? Format { get; set; }

        /// <summary>
        /// A list of known schemas and/or associations of schemas to file names.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("suggest", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CompletionConfiguration? Suggest { get; set; }

    }
}

namespace Monaco.Languages.Json
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface DiagnosticsOptions
    {
        /// <summary>
        /// If set, comments are tolerated. If set to false, syntax errors will be emitted for comments.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("allowComments", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AllowComments { get; set; }

        /// <summary>
        ///  If set, the schema service would load schema content on-demand with 'fetch' if available
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enableSchemaRequest", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? EnableSchemaRequest { get; set; }

        /// <summary>
        /// The severity of problems that occurred when resolving and loading schemas. If set to 'ignore', schema resolving problems are not reported. If not set, 'warning' is used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("schemaRequest", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? SchemaRequest { get; set; }

        /// <summary>
        /// The severity of problems from schema validation. If set to 'ignore', schema validation will be skipped. If not set, 'warning' is used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("schemaValidation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? SchemaValidation { get; set; }

        /// <summary>
        /// A list of known schemas and/or associations of schemas to file names.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("schemas", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        TypedocConverter.GeneratedTypes.LiteralSystemArrayFileMatchObjectSchemaStringUri[]? Schemas { get; set; }

        /// <summary>
        /// If set, the validator will be enabled and perform syntax validation as well as schema based validation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("validate", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Validate { get; set; }

    }
}

namespace Monaco.Languages.Json
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface LanguageServiceDefaults
    {
        [Newtonsoft.Json.JsonProperty("diagnosticsOptions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        DiagnosticsOptions DiagnosticsOptions { get; set; }

        [Newtonsoft.Json.JsonProperty("languageId", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string LanguageId { get; set; }

        [Newtonsoft.Json.JsonProperty("modeConfiguration", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ModeConfiguration ModeConfiguration { get; set; }

        [Newtonsoft.Json.JsonProperty("onDidChange", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEvent<LanguageServiceDefaults> OnDidChange { get; set; }

        void SetDiagnosticsOptions(DiagnosticsOptions options);

        void SetModeConfiguration(ModeConfiguration modeConfiguration);

    }
}

namespace Monaco.Languages.Json
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface ModeConfiguration
    {
        /// <summary>
        /// Defines whether the built-in color provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("colors", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Colors { get; set; }

        /// <summary>
        /// Defines whether the built-in completionItemProvider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("completionItems", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? CompletionItems { get; set; }

        /// <summary>
        /// Defines whether the built-in diagnostic provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("diagnostics", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Diagnostics { get; set; }

        /// <summary>
        /// Defines whether the built-in documentFormattingEdit provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentFormattingEdits", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DocumentFormattingEdits { get; set; }

        /// <summary>
        /// Defines whether the built-in documentRangeFormattingEdit provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentRangeFormattingEdits", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DocumentRangeFormattingEdits { get; set; }

        /// <summary>
        /// Defines whether the built-in documentSymbolProvider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentSymbols", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DocumentSymbols { get; set; }

        /// <summary>
        /// Defines whether the built-in foldingRange provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("foldingRanges", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? FoldingRanges { get; set; }

        /// <summary>
        /// Defines whether the built-in hoverProvider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hovers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Hovers { get; set; }

        /// <summary>
        /// Defines whether the built-in selection range provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectionRanges", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SelectionRanges { get; set; }

        /// <summary>
        /// Defines whether the built-in tokens provider is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tokens", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Tokens { get; set; }

    }
}

namespace Monaco.Languages.Json
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    [Newtonsoft.Json.JsonConverter(typeof(SeverityLevelConverter))]
    enum SeverityLevel
    {
        ///<summary>
        /// error
        ///</summary>
        Error,
        ///<summary>
        /// warning
        ///</summary>
        Warning,
        ///<summary>
        /// ignore
        ///</summary>
        Ignore
    }

    class SeverityLevelConverter : Newtonsoft.Json.JsonConverter
    {
        public override bool CanConvert(System.Type t) => t == typeof(SeverityLevel) || t == typeof(SeverityLevel?);

        public override object ReadJson(Newtonsoft.Json.JsonReader reader, System.Type t, object? existingValue, Newtonsoft.Json.JsonSerializer serializer)
            => reader.TokenType switch
            {
                Newtonsoft.Json.JsonToken.String =>
                    serializer.Deserialize<string>(reader) switch
                    {
                        "error" => SeverityLevel.Error,
                        "warning" => SeverityLevel.Warning,
                        "ignore" => SeverityLevel.Ignore,
                        _ => throw new System.NotSupportedException("Cannot unmarshal type SeverityLevel")
                    },
                _ => throw new System.NotSupportedException("Cannot unmarshal type SeverityLevel")
            };

        public override void WriteJson(Newtonsoft.Json.JsonWriter writer, object? untypedValue, Newtonsoft.Json.JsonSerializer serializer)
        {
            if (untypedValue is null) { serializer.Serialize(writer, null); return; }
            var value = (SeverityLevel)untypedValue;
            switch (value)
            {
                case SeverityLevel.Error: serializer.Serialize(writer, "error"); return;
                case SeverityLevel.Warning: serializer.Serialize(writer, "warning"); return;
                case SeverityLevel.Ignore: serializer.Serialize(writer, "ignore"); return;
                default: break;
            }
            throw new System.NotSupportedException("Cannot marshal type SeverityLevel");
        }
    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    enum JsxEmit
    {
        None = 0,
        Preserve = 1,
        React = 2,
        ReactJSX = 4,
        ReactJSXDev = 5,
        ReactNative = 3
    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    enum ModuleKind
    {
        AMD = 2,
        CommonJS = 1,
        ES2015 = 5,
        ESNext = 99,
        None = 0,
        System = 4,
        UMD = 3
    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    enum ModuleResolutionKind
    {
        Classic = 1,
        NodeJs = 2
    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    enum NewLineKind
    {
        CarriageReturnLineFeed = 0,
        LineFeed = 1
    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    enum ScriptTarget
    {
        ES2015 = 2,
        ES2016 = 3,
        ES2017 = 4,
        ES2018 = 5,
        ES2019 = 6,
        ES2020 = 7,
        ES3 = 0,
        ES5 = 1,
        ESNext = 99,
        JSON = 100,
        Latest = 99
    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface CompilerOptions
    {
        [Newtonsoft.Json.JsonProperty("allowJs", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AllowJs { get; set; }

        [Newtonsoft.Json.JsonProperty("allowSyntheticDefaultImports", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AllowSyntheticDefaultImports { get; set; }

        [Newtonsoft.Json.JsonProperty("allowUmdGlobalAccess", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AllowUmdGlobalAccess { get; set; }

        [Newtonsoft.Json.JsonProperty("allowUnreachableCode", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AllowUnreachableCode { get; set; }

        [Newtonsoft.Json.JsonProperty("allowUnusedLabels", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AllowUnusedLabels { get; set; }

        [Newtonsoft.Json.JsonProperty("alwaysStrict", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? AlwaysStrict { get; set; }

        [Newtonsoft.Json.JsonProperty("baseUrl", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? BaseUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("charset", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Charset { get; set; }

        [Newtonsoft.Json.JsonProperty("checkJs", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? CheckJs { get; set; }

        [Newtonsoft.Json.JsonProperty("composite", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Composite { get; set; }

        [Newtonsoft.Json.JsonProperty("declaration", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Declaration { get; set; }

        [Newtonsoft.Json.JsonProperty("declarationDir", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? DeclarationDir { get; set; }

        [Newtonsoft.Json.JsonProperty("declarationMap", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DeclarationMap { get; set; }

        [Newtonsoft.Json.JsonProperty("disableSizeLimit", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DisableSizeLimit { get; set; }

        [Newtonsoft.Json.JsonProperty("disableSourceOfProjectReferenceRedirect", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DisableSourceOfProjectReferenceRedirect { get; set; }

        [Newtonsoft.Json.JsonProperty("downlevelIteration", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? DownlevelIteration { get; set; }

        [Newtonsoft.Json.JsonProperty("emitBOM", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? EmitBOM { get; set; }

        [Newtonsoft.Json.JsonProperty("emitDeclarationOnly", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? EmitDeclarationOnly { get; set; }

        [Newtonsoft.Json.JsonProperty("emitDecoratorMetadata", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? EmitDecoratorMetadata { get; set; }

        [Newtonsoft.Json.JsonProperty("esModuleInterop", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? EsModuleInterop { get; set; }

        [Newtonsoft.Json.JsonProperty("experimentalDecorators", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ExperimentalDecorators { get; set; }

        [Newtonsoft.Json.JsonProperty("forceConsistentCasingInFileNames", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ForceConsistentCasingInFileNames { get; set; }

        [Newtonsoft.Json.JsonProperty("importHelpers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ImportHelpers { get; set; }

        [Newtonsoft.Json.JsonProperty("inlineSourceMap", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? InlineSourceMap { get; set; }

        [Newtonsoft.Json.JsonProperty("inlineSources", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? InlineSources { get; set; }

        [Newtonsoft.Json.JsonProperty("isolatedModules", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? IsolatedModules { get; set; }

        [Newtonsoft.Json.JsonProperty("jsx", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        JsxEmit? Jsx { get; set; }

        [Newtonsoft.Json.JsonProperty("jsxFactory", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? JsxFactory { get; set; }

        [Newtonsoft.Json.JsonProperty("keyofStringsOnly", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? KeyofStringsOnly { get; set; }

        [Newtonsoft.Json.JsonProperty("lib", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? Lib { get; set; }

        [Newtonsoft.Json.JsonProperty("locale", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Locale { get; set; }

        [Newtonsoft.Json.JsonProperty("mapRoot", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? MapRoot { get; set; }

        [Newtonsoft.Json.JsonProperty("maxNodeModuleJsDepth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? MaxNodeModuleJsDepth { get; set; }

        [Newtonsoft.Json.JsonProperty("module", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ModuleKind? Module { get; set; }

        [Newtonsoft.Json.JsonProperty("moduleResolution", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ModuleResolutionKind? ModuleResolution { get; set; }

        [Newtonsoft.Json.JsonProperty("newLine", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        NewLineKind? NewLine { get; set; }

        [Newtonsoft.Json.JsonProperty("noEmit", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoEmit { get; set; }

        [Newtonsoft.Json.JsonProperty("noEmitHelpers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoEmitHelpers { get; set; }

        [Newtonsoft.Json.JsonProperty("noEmitOnError", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoEmitOnError { get; set; }

        [Newtonsoft.Json.JsonProperty("noErrorTruncation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoErrorTruncation { get; set; }

        [Newtonsoft.Json.JsonProperty("noFallthroughCasesInSwitch", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoFallthroughCasesInSwitch { get; set; }

        [Newtonsoft.Json.JsonProperty("noImplicitAny", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoImplicitAny { get; set; }

        [Newtonsoft.Json.JsonProperty("noImplicitReturns", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoImplicitReturns { get; set; }

        [Newtonsoft.Json.JsonProperty("noImplicitThis", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoImplicitThis { get; set; }

        [Newtonsoft.Json.JsonProperty("noImplicitUseStrict", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoImplicitUseStrict { get; set; }

        [Newtonsoft.Json.JsonProperty("noLib", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoLib { get; set; }

        [Newtonsoft.Json.JsonProperty("noResolve", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoResolve { get; set; }

        [Newtonsoft.Json.JsonProperty("noStrictGenericChecks", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoStrictGenericChecks { get; set; }

        [Newtonsoft.Json.JsonProperty("noUnusedLocals", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoUnusedLocals { get; set; }

        [Newtonsoft.Json.JsonProperty("noUnusedParameters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoUnusedParameters { get; set; }

        [Newtonsoft.Json.JsonProperty("out", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Out { get; set; }

        [Newtonsoft.Json.JsonProperty("outDir", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? OutDir { get; set; }

        [Newtonsoft.Json.JsonProperty("outFile", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? OutFile { get; set; }

        [Newtonsoft.Json.JsonProperty("paths", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        MapLike<string[]>? Paths { get; set; }

        [Newtonsoft.Json.JsonProperty("preserveConstEnums", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? PreserveConstEnums { get; set; }

        [Newtonsoft.Json.JsonProperty("preserveSymlinks", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? PreserveSymlinks { get; set; }

        [Newtonsoft.Json.JsonProperty("project", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Project { get; set; }

        [Newtonsoft.Json.JsonProperty("reactNamespace", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? ReactNamespace { get; set; }

        [Newtonsoft.Json.JsonProperty("removeComments", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? RemoveComments { get; set; }

        [Newtonsoft.Json.JsonProperty("resolveJsonModule", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? ResolveJsonModule { get; set; }

        [Newtonsoft.Json.JsonProperty("rootDir", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? RootDir { get; set; }

        [Newtonsoft.Json.JsonProperty("rootDirs", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? RootDirs { get; set; }

        [Newtonsoft.Json.JsonProperty("skipDefaultLibCheck", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SkipDefaultLibCheck { get; set; }

        [Newtonsoft.Json.JsonProperty("skipLibCheck", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SkipLibCheck { get; set; }

        [Newtonsoft.Json.JsonProperty("sourceMap", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SourceMap { get; set; }

        [Newtonsoft.Json.JsonProperty("sourceRoot", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? SourceRoot { get; set; }

        [Newtonsoft.Json.JsonProperty("strict", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Strict { get; set; }

        [Newtonsoft.Json.JsonProperty("strictBindCallApply", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? StrictBindCallApply { get; set; }

        [Newtonsoft.Json.JsonProperty("strictFunctionTypes", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? StrictFunctionTypes { get; set; }

        [Newtonsoft.Json.JsonProperty("strictNullChecks", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? StrictNullChecks { get; set; }

        [Newtonsoft.Json.JsonProperty("strictPropertyInitialization", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? StrictPropertyInitialization { get; set; }

        [Newtonsoft.Json.JsonProperty("stripInternal", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? StripInternal { get; set; }

        [Newtonsoft.Json.JsonProperty("suppressExcessPropertyErrors", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SuppressExcessPropertyErrors { get; set; }

        [Newtonsoft.Json.JsonProperty("suppressImplicitAnyIndexErrors", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SuppressImplicitAnyIndexErrors { get; set; }

        [Newtonsoft.Json.JsonProperty("target", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ScriptTarget? Target { get; set; }

        [Newtonsoft.Json.JsonProperty("traceResolution", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? TraceResolution { get; set; }

        /// <summary>
        /// Paths used to compute primary types search locations
        /// </summary>
        [Newtonsoft.Json.JsonProperty("typeRoots", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? TypeRoots { get; set; }

        [Newtonsoft.Json.JsonProperty("types", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? Types { get; set; }

        [Newtonsoft.Json.JsonProperty("useDefineForClassFields", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? UseDefineForClassFields { get; set; }

    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface Diagnostic : DiagnosticRelatedInformation
    {
        [Newtonsoft.Json.JsonProperty("relatedInformation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        DiagnosticRelatedInformation[]? RelatedInformation { get; set; }

        /// <summary>
        /// May store more in future. For now, this will simply be `true` to indicate when a diagnostic is an unused-identifier diagnostic.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reportsUnnecessary", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object? ReportsUnnecessary { get; set; }

        [Newtonsoft.Json.JsonProperty("source", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Source { get; set; }

    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A linked list of formatted diagnostic messages to be used as part of a multiline message.
    /// It is built from the bottom up, leaving the head to be the "main" diagnostic.
    /// </summary>
    interface DiagnosticMessageChain
    {
        /// <summary>
        /// Diagnostic category: warning = 0, error = 1, suggestion = 2, message = 3
        /// </summary>
        [Newtonsoft.Json.JsonProperty("category", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Category { get; set; }

        [Newtonsoft.Json.JsonProperty("code", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Code { get; set; }

        [Newtonsoft.Json.JsonProperty("messageText", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string MessageText { get; set; }

        [Newtonsoft.Json.JsonProperty("next", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        DiagnosticMessageChain[]? Next { get; set; }

    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface DiagnosticRelatedInformation
    {
        /// <summary>
        /// Diagnostic category: warning = 0, error = 1, suggestion = 2, message = 3
        /// </summary>
        [Newtonsoft.Json.JsonProperty("category", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Category { get; set; }

        [Newtonsoft.Json.JsonProperty("code", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Code { get; set; }

        /// <summary>
        /// TypeScriptWorker removes this to avoid serializing circular JSON structures.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("file", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object File { get; set; }

        [Newtonsoft.Json.JsonProperty("length", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Length { get; set; }

        [Newtonsoft.Json.JsonProperty("messageText", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        DiagnosticMessageChain MessageText { get; set; }

        [Newtonsoft.Json.JsonProperty("start", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Start { get; set; }

    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface DiagnosticsOptions
    {
        [Newtonsoft.Json.JsonProperty("diagnosticCodesToIgnore", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double[]? DiagnosticCodesToIgnore { get; set; }

        [Newtonsoft.Json.JsonProperty("noSemanticValidation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoSemanticValidation { get; set; }

        [Newtonsoft.Json.JsonProperty("noSuggestionDiagnostics", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoSuggestionDiagnostics { get; set; }

        [Newtonsoft.Json.JsonProperty("noSyntaxValidation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? NoSyntaxValidation { get; set; }

    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface EmitOutput
    {
        [Newtonsoft.Json.JsonProperty("emitSkipped", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool EmitSkipped { get; set; }

        [Newtonsoft.Json.JsonProperty("outputFiles", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        OutputFile[] OutputFiles { get; set; }

    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IExtraLib
    {
        [Newtonsoft.Json.JsonProperty("content", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Content { get; set; }

        [Newtonsoft.Json.JsonProperty("version", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Version { get; set; }

    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface IExtraLibs
    {
    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface LanguageServiceDefaults
    {
        /// <summary>
        /// Event fired when compiler options or diagnostics options are changed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("onDidChange", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEvent<void> OnDidChange { get; set; }

        /// <summary>
        /// Event fired when extra libraries registered with the language service change.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("onDidExtraLibsChange", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEvent<void> OnDidExtraLibsChange { get; set; }

        [Newtonsoft.Json.JsonProperty("workerOptions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        WorkerOptions WorkerOptions { get; set; }

        /// <summary>
        /// Add an additional source file to the language service. Use this
        /// for typescript (definition) files that won't be loaded as editor
        /// documents, like `jquery.d.ts`.
        /// </summary>
        /// <returns>
        /// A disposable which will remove the file from the
        /// language service upon disposal.
        /// 
        /// </returns>
        IDisposable AddExtraLib(string content, string filePath);

        /// <summary>
        /// Get current TypeScript compiler options for the language service.
        /// </summary>
        CompilerOptions GetCompilerOptions();

        /// <summary>
        /// Get the current diagnostics options for the language service.
        /// </summary>
        DiagnosticsOptions GetDiagnosticsOptions();

        /// <summary>
        /// Get the current setting for whether all existing models should be eagerly sync'd
        /// to the worker on start or restart.
        /// </summary>
        bool GetEagerModelSync();

        /// <summary>
        /// Get the current extra libs registered with the language service.
        /// </summary>
        IExtraLibs GetExtraLibs();

        /// <summary>
        /// Set TypeScript compiler options.
        /// </summary>
        void SetCompilerOptions(CompilerOptions options);

        /// <summary>
        /// Configure whether syntactic and/or semantic validation should
        /// be performed
        /// </summary>
        void SetDiagnosticsOptions(DiagnosticsOptions options);

        /// <summary>
        /// Configure if all existing models should be eagerly sync'd
        /// to the worker on start or restart.
        /// </summary>
        void SetEagerModelSync(bool value);

        /// <summary>
        /// Remove all existing extra libs and set the additional source
        /// files to the language service. Use this for typescript definition
        /// files that won't be loaded as editor documents, like `jquery.d.ts`.
        /// </summary>
        void SetExtraLibs(TypedocConverter.GeneratedTypes.LiteralStringContentStringFilePath[] libs);

        /// <summary>
        /// No-op.
        /// </summary>
        void SetMaximumWorkerIdleTime(double value);

        /// <summary>
        /// Configure webworker options
        /// </summary>
        void SetWorkerOptions(WorkerOptions options);

    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface MapLike<T>
    {
    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface OutputFile
    {
        [Newtonsoft.Json.JsonProperty("name", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("text", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Text { get; set; }

        [Newtonsoft.Json.JsonProperty("writeByteOrderMark", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool WriteByteOrderMark { get; set; }

    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface TypeScriptWorker
    {
        /// <summary>
        /// Get other occurrences which should be updated when renaming the item at the given file and position.
        /// </summary>
        /// <returns>
        /// `Promise&lt;readonly typescript.RenameLocation[] | undefined&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object> FindRenameLocations(string fileName, double positon, bool findInStrings, bool findInComments, bool providePrefixAndSuffixTextForRename);

        /// <summary>
        /// Get possible code fixes at the given position in the file.
        /// </summary>
        /// <returns>
        /// `Promise&lt;ReadonlyArray&lt;typescript.CodeFixAction&gt;&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object> GetCodeFixesAtPosition(string fileName, double start, double end, double[] errorCodes, object formatOptions);

        /// <summary>
        /// Get diagnostic messages related to the current compiler options.
        /// </summary>
        System.Threading.Tasks.Task<Diagnostic[]> GetCompilerOptionsDiagnostics(string fileName);

        /// <summary>
        /// Get code completion details for the given file, position, and entry.
        /// </summary>
        /// <returns>
        /// `Promise&lt;typescript.CompletionEntryDetails | undefined&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object> GetCompletionEntryDetails(string fileName, double position, string entry);

        /// <summary>
        /// Get code completions for the given file and position.
        /// </summary>
        /// <returns>
        /// `Promise&lt;typescript.CompletionInfo | undefined&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object> GetCompletionsAtPosition(string fileName, double position);

        /// <summary>
        /// Get the definition of the item at the given position in the file.
        /// </summary>
        /// <returns>
        /// `Promise&lt;ReadonlyArray&lt;typescript.DefinitionInfo&gt; | undefined&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object> GetDefinitionAtPosition(string fileName, double position);

        /// <summary>
        /// Get transpiled output for the given file.
        /// </summary>
        /// <returns>
        /// `typescript.EmitOutput`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<EmitOutput> GetEmitOutput(string fileName);

        /// <summary>
        /// Get formatting changes which should be applied after the given keystroke.
        /// </summary>
        /// <returns>
        /// `Promise&lt;typescript.TextChange[]&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object[]> GetFormattingEditsAfterKeystroke(string fileName, double postion, string ch, object options);

        /// <summary>
        /// Get changes which should be applied to format the given file.
        /// </summary>
        /// <returns>
        /// `Promise&lt;typescript.TextChange[]&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object[]> GetFormattingEditsForDocument(string fileName, object options);

        /// <summary>
        /// Get changes which should be applied to format the given range in the file.
        /// </summary>
        /// <returns>
        /// `Promise&lt;typescript.TextChange[]&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object[]> GetFormattingEditsForRange(string fileName, double start, double end, object options);

        /// <summary>
        /// Get outline entries for the item at the given position in the file.
        /// </summary>
        /// <returns>
        /// `Promise&lt;typescript.NavigationBarItem[]&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object[]> GetNavigationBarItems(string fileName);

        /// <summary>
        /// Get other ranges which are related to the item at the given position in the file (often used for highlighting).
        /// </summary>
        /// <returns>
        /// `Promise&lt;ReadonlyArray&lt;typescript.ReferenceEntry&gt; | undefined&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object> GetOccurrencesAtPosition(string fileName, double position);

        /// <summary>
        /// Get quick info for the item at the given position in the file.
        /// </summary>
        /// <returns>
        /// `Promise&lt;typescript.QuickInfo | undefined&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object> GetQuickInfoAtPosition(string fileName, double position);

        /// <summary>
        /// Get references to the item at the given position in the file.
        /// </summary>
        /// <returns>
        /// `Promise&lt;typescript.ReferenceEntry[] | undefined&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object[]> GetReferencesAtPosition(string fileName, double position);

        /// <summary>
        /// Get edits which should be applied to rename the item at the given file and position (or a failure reason).
        /// </summary>
        /// <returns>
        /// `Promise&lt;typescript.RenameInfo&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object> GetRenameInfo(string fileName, double positon, object options);

        /// <summary>
        /// Get the content of a given file.
        /// </summary>
        System.Threading.Tasks.Task<string> GetScriptText(string fileName);

        /// <summary>
        /// Get diagnostic messages for any semantic issues in the given file.
        /// </summary>
        System.Threading.Tasks.Task<Diagnostic[]> GetSemanticDiagnostics(string fileName);

        /// <summary>
        /// Get signature help items for the item at the given file and position.
        /// </summary>
        /// <returns>
        /// `Promise&lt;typescript.SignatureHelpItems | undefined&gt;`
        /// 
        /// </returns>
        System.Threading.Tasks.Task<object> GetSignatureHelpItems(string fileName, double position, object options);

        /// <summary>
        /// Get diagnostic messages for any suggestions related to the given file.
        /// </summary>
        System.Threading.Tasks.Task<Diagnostic[]> GetSuggestionDiagnostics(string fileName);

        /// <summary>
        /// Get diagnostic messages for any syntax issues in the given file.
        /// </summary>
        System.Threading.Tasks.Task<Diagnostic[]> GetSyntacticDiagnostics(string fileName);

    }
}

namespace Monaco.Languages.Typescript
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface WorkerOptions
    {
        /// <summary>
        /// A full HTTP path to a JavaScript file which adds a function `customTSWorkerFactory` to the self inside a web-worker
        /// </summary>
        [Newtonsoft.Json.JsonProperty("customWorkerPath", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? CustomWorkerPath { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    enum CompletionItemInsertTextRule
    {
        /// <summary>
        /// `insertText` is a snippet.
        /// </summary>
        InsertAsSnippet = 4,
        /// <summary>
        /// Adjust whitespace/indentation of multiline insert texts to
        /// match the current line indentation.
        /// </summary>
        KeepWhitespace = 1
    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    enum CompletionItemKind
    {
        Class = 5,
        Color = 19,
        Constant = 14,
        Constructor = 2,
        Customcolor = 22,
        Enum = 15,
        EnumMember = 16,
        Event = 10,
        Field = 3,
        File = 20,
        Folder = 23,
        Function = 1,
        Interface = 7,
        Issue = 26,
        Keyword = 17,
        Method = 0,
        Module = 8,
        Operator = 11,
        Property = 9,
        Reference = 21,
        Snippet = 27,
        Struct = 6,
        Text = 18,
        TypeParameter = 24,
        Unit = 12,
        User = 25,
        Value = 13,
        Variable = 4
    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    enum CompletionItemTag
    {
        Deprecated = 1
    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// How a suggest provider was triggered.
    /// </summary>
    enum CompletionTriggerKind
    {
        Invoke = 0,
        TriggerCharacter = 1,
        TriggerForIncompleteCompletions = 2
    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A document highlight kind.
    /// </summary>
    enum DocumentHighlightKind
    {
        /// <summary>
        /// Read-access of a symbol, like reading a variable.
        /// </summary>
        Read = 1,
        /// <summary>
        /// A textual occurrence.
        /// </summary>
        Text = 0,
        /// <summary>
        /// Write-access of a symbol, like writing to a variable.
        /// </summary>
        Write = 2
    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Describes what to do with the indentation when pressing Enter.
    /// </summary>
    enum IndentAction
    {
        /// <summary>
        /// Insert new line and indent once (relative to the previous line's indentation).
        /// </summary>
        Indent = 1,
        /// <summary>
        /// Insert two new lines:
        ///  - the first one indented which will hold the cursor
        ///  - the second one at the same indentation level
        /// </summary>
        IndentOutdent = 2,
        /// <summary>
        /// Insert new line and copy the previous line's indentation.
        /// </summary>
        None = 0,
        /// <summary>
        /// Insert new line and outdent once (relative to the previous line's indentation).
        /// </summary>
        Outdent = 3
    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    enum SignatureHelpTriggerKind
    {
        ContentChange = 3,
        Invoke = 1,
        TriggerCharacter = 2
    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A symbol kind.
    /// </summary>
    enum SymbolKind
    {
        Array = 17,
        Boolean = 16,
        Class = 4,
        Constant = 13,
        Constructor = 8,
        Enum = 9,
        EnumMember = 21,
        Event = 23,
        Field = 7,
        File = 0,
        Function = 11,
        Interface = 10,
        Key = 19,
        Method = 5,
        Module = 1,
        Namespace = 2,
        Null = 20,
        Number = 15,
        Object = 18,
        Operator = 24,
        Package = 3,
        Property = 6,
        String = 14,
        Struct = 22,
        TypeParameter = 25,
        Variable = 12
    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    enum SymbolTag
    {
        Deprecated = 1
    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    class FoldingRangeKind
    {
        public FoldingRangeKind(string value) => throw new System.NotImplementedException();

        [Newtonsoft.Json.JsonProperty("value", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Kind for folding range representing a comment. The value of the kind is 'comment'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("Comment", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        static FoldingRangeKind Comment { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Kind for folding range representing a import. The value of the kind is 'imports'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("Imports", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        static FoldingRangeKind Imports { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Kind for folding range representing regions (for example marked by `#region`, `#endregion`).
        /// The value of the kind is 'region'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("Region", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        static FoldingRangeKind Region { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface CodeAction
    {
        [Newtonsoft.Json.JsonProperty("command", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Command? Command { get; set; }

        [Newtonsoft.Json.JsonProperty("diagnostics", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMarkerData[]? Diagnostics { get; set; }

        [Newtonsoft.Json.JsonProperty("disabled", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Disabled { get; set; }

        [Newtonsoft.Json.JsonProperty("edit", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        WorkspaceEdit? Edit { get; set; }

        [Newtonsoft.Json.JsonProperty("isPreferred", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? IsPreferred { get; set; }

        [Newtonsoft.Json.JsonProperty("kind", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Kind { get; set; }

        [Newtonsoft.Json.JsonProperty("title", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Title { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Contains additional diagnostic information about the context in which
    /// a [code action](#CodeActionProvider.provideCodeActions) is run.
    /// </summary>
    interface CodeActionContext
    {
        /// <summary>
        /// An array of diagnostics.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("markers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMarkerData[] Markers { get; set; }

        /// <summary>
        /// Requested kind of actions to return.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("only", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Only { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface CodeActionList : IDisposable
    {
        [Newtonsoft.Json.JsonProperty("actions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object Actions { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The code action interface defines the contract between extensions and
    /// the [light bulb](https://code.visualstudio.com/docs/editor/editingevolved#_code-action) feature.
    /// </summary>
    interface CodeActionProvider
    {
        /// <summary>
        /// Provide commands for the given document and range.
        /// </summary>
        ProviderResult<CodeActionList> ProvideCodeActions(ITextModel model, Range range, CodeActionContext context, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface CodeLens
    {
        [Newtonsoft.Json.JsonProperty("command", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Command? Command { get; set; }

        [Newtonsoft.Json.JsonProperty("id", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Id { get; set; }

        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface CodeLensList
    {
        [Newtonsoft.Json.JsonProperty("lenses", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CodeLens[] Lenses { get; set; }

        void Dispose();

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface CodeLensProvider
    {
        [Newtonsoft.Json.JsonProperty("onDidChange", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEvent<CodeLensProvider>? OnDidChange { get; set; }

        ProviderResult<CodeLensList> ProvideCodeLenses(ITextModel model, CancellationToken token);

        ProviderResult<CodeLens> ResolveCodeLens(ITextModel model, CodeLens codeLens, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface Command
    {
        [Newtonsoft.Json.JsonProperty("arguments", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object[]? Arguments { get; set; }

        [Newtonsoft.Json.JsonProperty("id", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("title", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Title { get; set; }

        [Newtonsoft.Json.JsonProperty("tooltip", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Tooltip { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Describes how comments for a language work.
    /// </summary>
    interface CommentRule
    {
        /// <summary>
        /// The block comment character pair, like `/* block comment *&amp;#47;`
        /// </summary>
        [Newtonsoft.Json.JsonProperty("blockComment", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CharacterPair? BlockComment { get; set; }

        /// <summary>
        /// The line comment token, like `// this is a comment`
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lineComment", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? LineComment { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Contains additional information about the context in which
    /// [completion provider](#CompletionItemProvider.provideCompletionItems) is triggered.
    /// </summary>
    interface CompletionContext
    {
        /// <summary>
        /// Character that triggered the completion item provider./// `undefined` if provider was not triggered by a character.
        /// 
        /// </summary>
        [Newtonsoft.Json.JsonProperty("triggerCharacter", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? TriggerCharacter { get; set; }

        /// <summary>
        /// How the completion was triggered.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("triggerKind", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CompletionTriggerKind TriggerKind { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A completion item represents a text snippet that is
    /// proposed to complete text that is being typed.
    /// </summary>
    interface CompletionItem
    {
        /// <summary>
        /// An optional array of additional text edits that are applied when
        /// selecting this completion. Edits must not overlap with the main edit
        /// nor with themselves.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("additionalTextEdits", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ISingleEditOperation[]? AdditionalTextEdits { get; set; }

        /// <summary>
        /// A command that should be run upon acceptance of this item.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("command", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Command? Command { get; set; }

        /// <summary>
        /// An optional set of characters that when pressed while this completion is active will accept it first and
        /// then type that character. *Note* that all commit characters should have `length=1` and that superfluous
        /// characters will be ignored.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("commitCharacters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? CommitCharacters { get; set; }

        /// <summary>
        /// A human-readable string with additional information
        /// about this item, like type or symbol information.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("detail", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Detail { get; set; }

        /// <summary>
        /// A human-readable string that represents a doc-comment.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMarkdownString? Documentation { get; set; }

        /// <summary>
        /// A string that should be used when filtering a set of
        /// completion items. When `falsy` the [label](#CompletionItem.label)
        /// is used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("filterText", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? FilterText { get; set; }

        /// <summary>
        /// A string or snippet that should be inserted in a document when selecting
        /// this completion.
        /// is used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("insertText", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string InsertText { get; set; }

        /// <summary>
        /// Addition rules (as bitmask) that should be applied when inserting
        /// this completion.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("insertTextRules", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CompletionItemInsertTextRule? InsertTextRules { get; set; }

        /// <summary>
        /// The kind of this completion item. Based on the kind
        /// an icon is chosen by the editor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kind", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CompletionItemKind Kind { get; set; }

        /// <summary>
        /// The label of this completion item. By default
        /// this is also the text that is inserted when selecting
        /// this completion.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("label", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CompletionItemLabel Label { get; set; }

        /// <summary>
        /// Select this item when showing. *Note* that only one completion item can be selected and
        /// that the editor decides which item that is. The rule is that the *first* item of those
        /// that match best is selected.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("preselect", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Preselect { get; set; }

        /// <summary>
        /// A range of text that should be replaced by this completion item./// Defaults to a range from the start of the [current word](#TextDocument.getWordRangeAtPosition) to the
        /// current position.
        /// 
        /// *Note:* The range must be a [single line](#Range.isSingleLine) and it must
        /// [contain](#Range.contains) the position at which completion has been [requested](#CompletionItemProvider.provideCompletionItems).
        /// 
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

        /// <summary>
        /// A string that should be used when comparing this item
        /// with other items. When `falsy` the [label](#CompletionItem.label)
        /// is used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sortText", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? SortText { get; set; }

        /// <summary>
        /// A modifier to the `kind` which affect how the item
        /// is rendered, e.g. Deprecated is rendered with a strikeout
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tags", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object? Tags { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface CompletionItemLabel
    {
        /// <summary>
        /// The function or variable. Rendered leftmost.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Name { get; set; }

        /// <summary>
        /// The parameters without the return type. Render after `name`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parameters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Parameters { get; set; }

        /// <summary>
        /// The fully qualified name, like package name or file path. Rendered after `signature`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("qualifier", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Qualifier { get; set; }

        /// <summary>
        /// The return-type of a function or type of a property/variable. Rendered rightmost.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Type { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The completion item provider interface defines the contract between extensions and
    /// the [IntelliSense](https://code.visualstudio.com/docs/editor/intellisense)./// When computing *complete* completion items is expensive, providers can optionally implement
    /// the `resolveCompletionItem`-function. In that case it is enough to return completion
    /// items with a [label](#CompletionItem.label) from the
    /// [provideCompletionItems](#CompletionItemProvider.provideCompletionItems)-function. Subsequently,
    /// when a completion item is shown in the UI and gains focus this provider is asked to resolve
    /// the item, like adding [doc-comment](#CompletionItem.documentation) or [details](#CompletionItem.detail).
    /// 
    /// </summary>
    interface CompletionItemProvider
    {
        [Newtonsoft.Json.JsonProperty("triggerCharacters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? TriggerCharacters { get; set; }

        /// <summary>
        /// Provide completion items for the given position and document.
        /// </summary>
        ProviderResult<CompletionList> ProvideCompletionItems(ITextModel model, Position position, CompletionContext context, CancellationToken token);

        /// <summary>
        /// Given a completion item fill in more data, like [doc-comment](#CompletionItem.documentation)
        /// or [details](#CompletionItem.detail)./// The editor will only resolve a completion item once.
        /// 
        /// </summary>
        ProviderResult<CompletionItem> ResolveCompletionItem(CompletionItem item, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface CompletionList
    {
        [Newtonsoft.Json.JsonProperty("incomplete", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Incomplete { get; set; }

        [Newtonsoft.Json.JsonProperty("suggestions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CompletionItem[] Suggestions { get; set; }

        void Dispose();

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The definition provider interface defines the contract between extensions and
    /// the [go to definition](https://code.visualstudio.com/docs/editor/editingevolved#_go-to-definition)
    /// and peek definition features.
    /// </summary>
    interface DeclarationProvider
    {
        /// <summary>
        /// Provide the declaration of the symbol at the given position and document.
        /// </summary>
        ProviderResult<Definition> ProvideDeclaration(ITextModel model, Position position, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The definition provider interface defines the contract between extensions and
    /// the [go to definition](https://code.visualstudio.com/docs/editor/editingevolved#_go-to-definition)
    /// and peek definition features.
    /// </summary>
    interface DefinitionProvider
    {
        /// <summary>
        /// Provide the definition of the symbol at the given position and document.
        /// </summary>
        ProviderResult<Definition> ProvideDefinition(ITextModel model, Position position, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A provider of colors for editor models.
    /// </summary>
    interface DocumentColorProvider
    {
        /// <summary>
        /// Provide the string representations for a color.
        /// </summary>
        ProviderResult<IColorPresentation[]> ProvideColorPresentations(ITextModel model, IColorInformation colorInfo, CancellationToken token);

        /// <summary>
        /// Provides the color ranges for a specific model.
        /// </summary>
        ProviderResult<IColorInformation[]> ProvideDocumentColors(ITextModel model, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The document formatting provider interface defines the contract between extensions and
    /// the formatting-feature.
    /// </summary>
    interface DocumentFormattingEditProvider
    {
        [Newtonsoft.Json.JsonProperty("displayName", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? DisplayName { get; set; }

        /// <summary>
        /// Provide formatting edits for a whole document.
        /// </summary>
        ProviderResult<TextEdit[]> ProvideDocumentFormattingEdits(ITextModel model, FormattingOptions options, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A document highlight is a range inside a text document which deserves
    /// special attention. Usually a document highlight is visualized by changing
    /// the background color of its range.
    /// </summary>
    interface DocumentHighlight
    {
        /// <summary>
        /// The highlight kind, default is [text](#DocumentHighlightKind.Text).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kind", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        DocumentHighlightKind? Kind { get; set; }

        /// <summary>
        /// The range this highlight applies to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The document highlight provider interface defines the contract between extensions and
    /// the word-highlight-feature.
    /// </summary>
    interface DocumentHighlightProvider
    {
        /// <summary>
        /// Provide a set of document highlights, like all occurrences of a variable or
        /// all exit-points of a function.
        /// </summary>
        ProviderResult<DocumentHighlight[]> ProvideDocumentHighlights(ITextModel model, Position position, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The document formatting provider interface defines the contract between extensions and
    /// the formatting-feature.
    /// </summary>
    interface DocumentRangeFormattingEditProvider
    {
        [Newtonsoft.Json.JsonProperty("displayName", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? DisplayName { get; set; }

        /// <summary>
        /// Provide formatting edits for a range in a document./// The given range is a hint and providers can decide to format a smaller
        /// or larger range. Often this is done by adjusting the start and end
        /// of the range to full syntax nodes.
        /// 
        /// </summary>
        ProviderResult<TextEdit[]> ProvideDocumentRangeFormattingEdits(ITextModel model, Range range, FormattingOptions options, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface DocumentRangeSemanticTokensProvider
    {
        SemanticTokensLegend GetLegend();

        ProviderResult<SemanticTokens> ProvideDocumentRangeSemanticTokens(ITextModel model, Range range, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface DocumentSemanticTokensProvider
    {
        [Newtonsoft.Json.JsonProperty("onDidChange", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEvent<void>? OnDidChange { get; set; }

        SemanticTokensLegend GetLegend();

        ProviderResult<SemanticTokens> ProvideDocumentSemanticTokens(ITextModel model, string lastResultId, CancellationToken token);

        void ReleaseDocumentSemanticTokens(string resultId);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface DocumentSymbol
    {
        [Newtonsoft.Json.JsonProperty("children", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        DocumentSymbol[]? Children { get; set; }

        [Newtonsoft.Json.JsonProperty("containerName", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? ContainerName { get; set; }

        [Newtonsoft.Json.JsonProperty("detail", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Detail { get; set; }

        [Newtonsoft.Json.JsonProperty("kind", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        SymbolKind Kind { get; set; }

        [Newtonsoft.Json.JsonProperty("name", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

        [Newtonsoft.Json.JsonProperty("selectionRange", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange SelectionRange { get; set; }

        [Newtonsoft.Json.JsonProperty("tags", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object Tags { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The document symbol provider interface defines the contract between extensions and
    /// the [go to symbol](https://code.visualstudio.com/docs/editor/editingevolved#_go-to-symbol)-feature.
    /// </summary>
    interface DocumentSymbolProvider
    {
        [Newtonsoft.Json.JsonProperty("displayName", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? DisplayName { get; set; }

        /// <summary>
        /// Provide symbol information for the given document.
        /// </summary>
        ProviderResult<DocumentSymbol[]> ProvideDocumentSymbols(ITextModel model, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A "manual" provider of tokens, returning tokens in a binary form.
    /// </summary>
    interface EncodedTokensProvider
    {
        /// <summary>
        /// The initial state of a language. Will be the state passed in to tokenize the first line.
        /// </summary>
        IState GetInitialState();

        /// <summary>
        /// Tokenize a line given the state at the beginning of the line.
        /// </summary>
        ILineTokens Tokenize(string line, IState state);

        /// <summary>
        /// Tokenize a line given the state at the beginning of the line.
        /// </summary>
        IEncodedLineTokens TokenizeEncoded(string line, IState state);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Describes what to do when pressing Enter.
    /// </summary>
    interface EnterAction
    {
        /// <summary>
        /// Describes text to be appended after the new line and after the indentation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("appendText", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AppendText { get; set; }

        /// <summary>
        /// Describe what to do with the indentation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("indentAction", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IndentAction IndentAction { get; set; }

        /// <summary>
        /// Describes the number of characters to remove from the new line's indentation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("removeText", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? RemoveText { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface FoldingContext
    {
    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Describes language specific folding markers such as '#region' and '#endregion'.
    /// The start and end regexes will be tested against the contents of all lines and must be designed efficiently:
    /// - the regex should start with '^'
    /// - regexp flags (i, g) are ignored
    /// </summary>
    interface FoldingMarkers
    {
        [Newtonsoft.Json.JsonProperty("end", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string End { get; set; }

        [Newtonsoft.Json.JsonProperty("start", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Start { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface FoldingRange
    {
        /// <summary>
        /// The one-based end line of the range to fold. The folded area ends with the line's last character.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("end", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double End { get; set; }

        /// <summary>
        /// Describes the [Kind](#FoldingRangeKind) of the folding range such as [Comment](#FoldingRangeKind.Comment) or
        /// [Region](#FoldingRangeKind.Region). The kind is used to categorize folding ranges and used by commands
        /// like 'Fold all comments'. See
        /// [FoldingRangeKind](#FoldingRangeKind) for an enumeration of standardized kinds.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kind", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        FoldingRangeKind? Kind { get; set; }

        /// <summary>
        /// The one-based start line of the range to fold. The folded area starts after the line's last character.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("start", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Start { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A provider of folding ranges for editor models.
    /// </summary>
    interface FoldingRangeProvider
    {
        /// <summary>
        /// An optional event to signal that the folding ranges from this provider have changed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("onDidChange", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEvent<FoldingRangeProvider>? OnDidChange { get; set; }

        /// <summary>
        /// Provides the folding ranges for a specific model.
        /// </summary>
        ProviderResult<FoldingRange[]> ProvideFoldingRanges(ITextModel model, FoldingContext context, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Describes folding rules for a language.
    /// </summary>
    interface FoldingRules
    {
        /// <summary>
        /// Region markers used by the language.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("markers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        FoldingMarkers? Markers { get; set; }

        /// <summary>
        /// Used by the indentation based strategy to decide whether empty lines belong to the previous or the next block.
        /// A language adheres to the off-side rule if blocks in that language are expressed by their indentation.
        /// See [wikipedia](https://en.wikipedia.org/wiki/Off-side_rule) for more information.
        /// If not set, `false` is used and empty lines belong to the previous block.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("offSide", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? OffSide { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Interface used to format a model
    /// </summary>
    interface FormattingOptions
    {
        /// <summary>
        /// Prefer spaces over tabs.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("insertSpaces", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool InsertSpaces { get; set; }

        /// <summary>
        /// Size of a tab in spaces.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tabSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double TabSize { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A hover represents additional information for a symbol or word. Hovers are
    /// rendered in a tooltip-like widget.
    /// </summary>
    interface Hover
    {
        /// <summary>
        /// The contents of this hover.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("contents", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMarkdownString[] Contents { get; set; }

        /// <summary>
        /// The range to which this hover applies. When missing, the
        /// editor will use the range at the current position or the
        /// current position itself.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange? Range { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The hover provider interface defines the contract between extensions and
    /// the [hover](https://code.visualstudio.com/docs/editor/intellisense)-feature.
    /// </summary>
    interface HoverProvider
    {
        /// <summary>
        /// Provide a hover for the given position and document. Multiple hovers at the same
        /// position will be merged by the editor. A hover can have a range which defaults
        /// to the word range at the position when omitted.
        /// </summary>
        ProviderResult<Hover> ProvideHover(ITextModel model, Position position, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface IAutoClosingPair
    {
        [Newtonsoft.Json.JsonProperty("close", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Close { get; set; }

        [Newtonsoft.Json.JsonProperty("open", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Open { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface IAutoClosingPairConditional : IAutoClosingPair
    {
        [Newtonsoft.Json.JsonProperty("notIn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? NotIn { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A color in RGBA format.
    /// </summary>
    interface IColor
    {
        /// <summary>
        /// The alpha component in the range [0-1].
        /// </summary>
        [Newtonsoft.Json.JsonProperty("alpha", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Alpha { get; set; }

        /// <summary>
        /// The blue component in the range [0-1].
        /// </summary>
        [Newtonsoft.Json.JsonProperty("blue", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Blue { get; set; }

        /// <summary>
        /// The green component in the range [0-1].
        /// </summary>
        [Newtonsoft.Json.JsonProperty("green", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Green { get; set; }

        /// <summary>
        /// The red component in the range [0-1].
        /// </summary>
        [Newtonsoft.Json.JsonProperty("red", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Red { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A color range is a range in a text model which represents a color.
    /// </summary>
    interface IColorInformation
    {
        /// <summary>
        /// The color represented in this range.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("color", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IColor Color { get; set; }

        /// <summary>
        /// The range within the model.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// String representations for a color
    /// </summary>
    interface IColorPresentation
    {
        /// <summary>
        /// An optional array of additional [text edits](#TextEdit) that are applied when
        /// selecting this color presentation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("additionalTextEdits", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        TextEdit[]? AdditionalTextEdits { get; set; }

        /// <summary>
        /// The label of this color presentation. It will be shown on the color
        /// picker header. By default this is also the text that is inserted when selecting
        /// this color presentation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("label", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Label { get; set; }

        /// <summary>
        /// An [edit](#TextEdit) which is applied to a document when selecting
        /// this presentation for the color.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("textEdit", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        TextEdit? TextEdit { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Definition of documentation comments (e.g. Javadoc/JSdoc)
    /// </summary>
    interface IDocComment
    {
        /// <summary>
        /// The string that appears on the last line and closes the doc comment (e.g. ' * /').
        /// </summary>
        [Newtonsoft.Json.JsonProperty("close", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Close { get; set; }

        /// <summary>
        /// The string that starts a doc comment (e.g. '/**')
        /// </summary>
        [Newtonsoft.Json.JsonProperty("open", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Open { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The result of a line tokenization.
    /// </summary>
    interface IEncodedLineTokens
    {
        /// <summary>
        /// The tokenization end state.
        /// A pointer will be held to this and the object should not be modified by the tokenizer after the pointer is returned.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endState", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IState EndState { get; set; }

        /// <summary>
        /// The tokens on the line in a binary, encoded format. Each token occupies two array indices. For token i:
        ///  - at offset 2*i =&gt; startIndex
        ///  - at offset 2*i + 1 =&gt; metadata
        /// Meta data is in binary format:
        /// - -------------------------------------------
        ///     3322 2222 2222 1111 1111 1100 0000 0000
        ///     1098 7654 3210 9876 5432 1098 7654 3210
        /// - -------------------------------------------
        ///     bbbb bbbb bfff ffff ffFF FTTT LLLL LLLL
        /// - -------------------------------------------
        ///  - L = EncodedLanguageId (8 bits): Use `getEncodedLanguageId` to get the encoded ID of a language.
        ///  - T = StandardTokenType (3 bits): Other = 0, Comment = 1, String = 2, RegEx = 4.
        ///  - F = FontStyle (3 bits): None = 0, Italic = 1, Bold = 2, Underline = 4.
        ///  - f = foreground ColorId (9 bits)
        ///  - b = background ColorId (9 bits)
        ///  - The color value for each colorId is defined in IStandaloneThemeData.customTokenColors:
        /// e.g. colorId = 1 is stored in IStandaloneThemeData.customTokenColors[1]. Color id = 0 means no color,
        /// id = 1 is for the default foreground color, id = 2 for the default background.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tokens", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        uint[] Tokens { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface IExpandedMonarchLanguageAction
    {
        /// <summary>
        
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bracket", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Bracket { get; set; }

        /// <summary>
        /// map from string to ILanguageAction
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cases", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Object? Cases { get; set; }

        /// <summary>
        /// go back n characters in the stream
        /// </summary>
        [Newtonsoft.Json.JsonProperty("goBack", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? GoBack { get; set; }

        /// <summary>
        /// array of actions for each parenthesized match group
        /// </summary>
        [Newtonsoft.Json.JsonProperty("group", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMonarchLanguageAction[]? Group { get; set; }

        /// <summary>
        /// log a message to the browser console window
        /// </summary>
        [Newtonsoft.Json.JsonProperty("log", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Log { get; set; }

        /// <summary>
        /// the next state to push, or "@push", "@pop", "@popall"
        /// </summary>
        [Newtonsoft.Json.JsonProperty("next", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Next { get; set; }

        /// <summary>
        /// switch to embedded language (using the mimetype) or get out using "@pop"
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nextEmbedded", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? NextEmbedded { get; set; }

        /// <summary>
        /// switch to this state
        /// </summary>
        [Newtonsoft.Json.JsonProperty("switchTo", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? SwitchTo { get; set; }

        /// <summary>
        /// token class (ie. css class) (or "@brackets" or "@rematch")
        /// </summary>
        [Newtonsoft.Json.JsonProperty("token", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Token { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface IExpandedMonarchLanguageRule
    {
        /// <summary>
        /// action to take on match
        /// </summary>
        [Newtonsoft.Json.JsonProperty("action", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMonarchLanguageAction? Action { get; set; }

        /// <summary>
        /// or an include rule. include all rules from the included state
        /// </summary>
        [Newtonsoft.Json.JsonProperty("include", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Include { get; set; }

        /// <summary>
        /// match tokens
        /// </summary>
        [Newtonsoft.Json.JsonProperty("regex", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Regex { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface ILanguageExtensionPoint
    {
        [Newtonsoft.Json.JsonProperty("aliases", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? Aliases { get; set; }

        [Newtonsoft.Json.JsonProperty("configuration", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri? Configuration { get; set; }

        [Newtonsoft.Json.JsonProperty("extensions", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? Extensions { get; set; }

        [Newtonsoft.Json.JsonProperty("filenamePatterns", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? FilenamePatterns { get; set; }

        [Newtonsoft.Json.JsonProperty("filenames", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? Filenames { get; set; }

        [Newtonsoft.Json.JsonProperty("firstLine", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? FirstLine { get; set; }

        [Newtonsoft.Json.JsonProperty("id", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("mimetypes", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[]? Mimetypes { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The result of a line tokenization.
    /// </summary>
    interface ILineTokens
    {
        /// <summary>
        /// The tokenization end state.
        /// A pointer will be held to this and the object should not be modified by the tokenizer after the pointer is returned.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endState", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IState EndState { get; set; }

        /// <summary>
        /// The list of tokens on the line.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tokens", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IToken[] Tokens { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A link inside the editor.
    /// </summary>
    interface ILink
    {
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

        [Newtonsoft.Json.JsonProperty("tooltip", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Tooltip { get; set; }

        [Newtonsoft.Json.JsonProperty("url", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri? Url { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface ILinksList
    {
        [Newtonsoft.Json.JsonProperty("links", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ILink[] Links { get; set; }

        void Dispose();

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A Monarch language definition
    /// </summary>
    interface IMonarchLanguage
    {
        /// <summary>
        /// for example [['{','}','delimiter.curly']]
        /// </summary>
        [Newtonsoft.Json.JsonProperty("brackets", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMonarchLanguageBracket[]? Brackets { get; set; }

        /// <summary>
        /// if no match in the tokenizer assign this token class (default 'source')
        /// </summary>
        [Newtonsoft.Json.JsonProperty("defaultToken", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? DefaultToken { get; set; }

        /// <summary>
        /// is the language case insensitive?
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ignoreCase", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? IgnoreCase { get; set; }

        /// <summary>
        /// include line feeds (in the form of a \n character) at the end of lines
        /// Defaults to false
        /// </summary>
        [Newtonsoft.Json.JsonProperty("includeLF", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? IncludeLF { get; set; }

        /// <summary>
        /// start symbol in the tokenizer (by default the first entry is used)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("start", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Start { get; set; }

        /// <summary>
        /// attach this to every token class (by default '.' + name)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tokenPostfix", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? TokenPostfix { get; set; }

        /// <summary>
        /// map from string to ILanguageRule[]
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tokenizer", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        System.Collections.Generic.IDictionary<string, IMonarchLanguageRule[]> Tokenizer { get; set; }

        /// <summary>
        /// is the language unicode-aware? (i.e., /\u{1D306}/)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("unicode", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Unicode { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// This interface can be shortened as an array, ie. ['{','}','delimiter.curly']
    /// </summary>
    interface IMonarchLanguageBracket
    {
        /// <summary>
        /// closing bracket
        /// </summary>
        [Newtonsoft.Json.JsonProperty("close", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Close { get; set; }

        /// <summary>
        /// open bracket
        /// </summary>
        [Newtonsoft.Json.JsonProperty("open", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Open { get; set; }

        /// <summary>
        /// token class
        /// </summary>
        [Newtonsoft.Json.JsonProperty("token", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Token { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The state of the tokenizer between two lines.
    /// It is useful to store flags such as in multiline comment, etc.
    /// The model will clone the previous line's state and pass it in to tokenize the next line.
    /// </summary>
    interface IState
    {
        IState Clone();

        bool Equals(IState other);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A token.
    /// </summary>
    interface IToken
    {
        [Newtonsoft.Json.JsonProperty("scopes", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Scopes { get; set; }

        [Newtonsoft.Json.JsonProperty("startIndex", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double StartIndex { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The implementation provider interface defines the contract between extensions and
    /// the go to implementation feature.
    /// </summary>
    interface ImplementationProvider
    {
        /// <summary>
        /// Provide the implementation of the symbol at the given position and document.
        /// </summary>
        ProviderResult<Definition> ProvideImplementation(ITextModel model, Position position, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Describes indentation rules for a language.
    /// </summary>
    interface IndentationRule
    {
        /// <summary>
        /// If a line matches this pattern, then all the lines after it should be unindented once (until another rule matches).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("decreaseIndentPattern", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string DecreaseIndentPattern { get; set; }

        /// <summary>
        /// If a line matches this pattern, then all the lines after it should be indented once (until another rule matches).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("increaseIndentPattern", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string IncreaseIndentPattern { get; set; }

        /// <summary>
        /// If a line matches this pattern, then **only the next line** after it should be indented once.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("indentNextLinePattern", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? IndentNextLinePattern { get; set; }

        /// <summary>
        /// If a line matches this pattern, then its indentation should not be changed and it should not be evaluated against the other rules.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("unIndentedLinePattern", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? UnIndentedLinePattern { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface InlineHint
    {
        [Newtonsoft.Json.JsonProperty("description", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMarkdownString? Description { get; set; }

        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

        [Newtonsoft.Json.JsonProperty("text", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Text { get; set; }

        [Newtonsoft.Json.JsonProperty("whitespaceAfter", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? WhitespaceAfter { get; set; }

        [Newtonsoft.Json.JsonProperty("whitespaceBefore", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? WhitespaceBefore { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface InlineHintsProvider
    {
        [Newtonsoft.Json.JsonProperty("onDidChangeInlineHints", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IEvent<void>? OnDidChangeInlineHints { get; set; }

        ProviderResult<InlineHint[]> ProvideInlineHints(ITextModel model, Range range, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The language configuration interface defines the contract between extensions and
    /// various editor features, like automatic bracket insertion, automatic indentation etc.
    /// </summary>
    interface LanguageConfiguration
    {
        /// <summary>
        /// **Deprecated** Do not use.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("__electricCharacterSupport", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        TypedocConverter.GeneratedTypes.LiteralIDocCommentDocComment? ElectricCharacterSupport { get; set; }

        /// <summary>
        /// Defines what characters must be after the cursor for bracket or quote autoclosing to occur when using the \'languageDefined\' autoclosing setting./// This is typically the set of characters which can not start an expression, such as whitespace, closing brackets, non-unary operators, etc.
        /// 
        /// </summary>
        [Newtonsoft.Json.JsonProperty("autoCloseBefore", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AutoCloseBefore { get; set; }

        /// <summary>
        /// The language's auto closing pairs. The 'close' character is automatically inserted with the
        /// 'open' character is typed. If not set, the configured brackets will be used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("autoClosingPairs", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IAutoClosingPairConditional[]? AutoClosingPairs { get; set; }

        /// <summary>
        /// The language's brackets.
        /// This configuration implicitly affects pressing Enter around these brackets.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("brackets", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CharacterPair[]? Brackets { get; set; }

        /// <summary>
        /// The language's comment settings.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("comments", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        CommentRule? Comments { get; set; }

        /// <summary>
        /// The language's folding rules.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("folding", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        FoldingRules? Folding { get; set; }

        /// <summary>
        /// The language's indentation settings.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("indentationRules", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IndentationRule? IndentationRules { get; set; }

        /// <summary>
        /// The language's rules to be evaluated when pressing Enter.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("onEnterRules", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        OnEnterRule[]? OnEnterRules { get; set; }

        /// <summary>
        /// The language's surrounding pairs. When the 'open' character is typed on a selection, the
        /// selected string is surrounded by the open and close characters. If not set, the autoclosing pairs
        /// settings will be used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("surroundingPairs", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IAutoClosingPair[]? SurroundingPairs { get; set; }

        /// <summary>
        /// The language's word definition.
        /// If the language supports Unicode identifiers (e.g. JavaScript), it is preferable
        /// to provide a word definition that uses exclusion of known separators.
        /// e.g.: A regex that matches anything except known separators (and dot is allowed to occur in a floating point number):
        ///   /(-?\d*\.\d\w*)|([^\`\~\!\@\#\%\^\&amp;\*\(\)\-\=\+\[\{\]\}\\\|\;\:\'\"\,\.\&lt;\&gt;\/\?\s]+)/g
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wordPattern", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? WordPattern { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A provider of links.
    /// </summary>
    interface LinkProvider
    {
        [Newtonsoft.Json.JsonProperty("resolveLink", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        System.Func<ILink, CancellationToken, ProviderResult<ILink>>? ResolveLink { get; set; }

        ProviderResult<ILinksList> ProvideLinks(ITextModel model, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The linked editing range provider interface defines the contract between extensions and
    /// the linked editing feature.
    /// </summary>
    interface LinkedEditingRangeProvider
    {
        /// <summary>
        /// Provide a list of ranges that can be edited together.
        /// </summary>
        ProviderResult<LinkedEditingRanges> ProvideLinkedEditingRanges(ITextModel model, Position position, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Represents a list of ranges that can be edited together along with a word pattern to describe valid contents.
    /// </summary>
    interface LinkedEditingRanges
    {
        /// <summary>
        /// A list of ranges that can be edited together. The ranges must have
        /// identical length and text content. The ranges cannot overlap
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ranges", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange[] Ranges { get; set; }

        /// <summary>
        /// An optional word pattern that describes valid contents for the given ranges.
        /// If no pattern is provided, the language configuration's word pattern will be used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wordPattern", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? WordPattern { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Represents a location inside a resource, such as a line
    /// inside a text file.
    /// </summary>
    interface Location
    {
        /// <summary>
        /// The document range of this locations.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

        /// <summary>
        /// The resource identifier of this location.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("uri", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri Uri { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface LocationLink
    {
        /// <summary>
        /// A range to select where this link originates from.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("originSelectionRange", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange? OriginSelectionRange { get; set; }

        /// <summary>
        /// The full range this link points to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

        /// <summary>
        /// A range to select this link points to. Must be contained
        /// in `LocationLink.range`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetSelectionRange", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange? TargetSelectionRange { get; set; }

        /// <summary>
        /// The target uri this link points to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("uri", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri Uri { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Describes a rule to be evaluated when pressing Enter.
    /// </summary>
    interface OnEnterRule
    {
        /// <summary>
        /// The action to execute.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("action", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        EnterAction Action { get; set; }

        /// <summary>
        /// This rule will only execute if the text after the cursor matches this regular expression.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("afterText", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? AfterText { get; set; }

        /// <summary>
        /// This rule will only execute if the text before the cursor matches this regular expression.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("beforeText", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string BeforeText { get; set; }

        /// <summary>
        /// This rule will only execute if the text above the this line matches this regular expression.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("previousLineText", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? PreviousLineText { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The document formatting provider interface defines the contract between extensions and
    /// the formatting-feature.
    /// </summary>
    interface OnTypeFormattingEditProvider
    {
        [Newtonsoft.Json.JsonProperty("autoFormatTriggerCharacters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[] AutoFormatTriggerCharacters { get; set; }

        /// <summary>
        /// Provide formatting edits after a character has been typed./// The given position and character should hint to the provider
        /// what range the position to expand to, like find the matching `{`
        /// when `}` has been entered.
        /// 
        /// </summary>
        ProviderResult<TextEdit[]> ProvideOnTypeFormattingEdits(ITextModel model, Position position, string ch, FormattingOptions options, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Represents a parameter of a callable-signature. A parameter can
    /// have a label and a doc-comment.
    /// </summary>
    interface ParameterInformation
    {
        /// <summary>
        /// The human-readable doc-comment of this signature. Will be shown
        /// in the UI but can be omitted.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMarkdownString? Documentation { get; set; }

        /// <summary>
        /// The label of this signature. Will be shown in
        /// the UI.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("label", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Label { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Value-object that contains additional information when
    /// requesting references.
    /// </summary>
    interface ReferenceContext
    {
        /// <summary>
        /// Include the declaration of the current symbol.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("includeDeclaration", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IncludeDeclaration { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The reference provider interface defines the contract between extensions and
    /// the [find references](https://code.visualstudio.com/docs/editor/editingevolved#_peek)-feature.
    /// </summary>
    interface ReferenceProvider
    {
        /// <summary>
        /// Provide a set of project-wide references for the given position and document.
        /// </summary>
        ProviderResult<Location[]> ProvideReferences(ITextModel model, Position position, ReferenceContext context, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface Rejection
    {
        [Newtonsoft.Json.JsonProperty("rejectReason", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? RejectReason { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface RenameLocation
    {
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

        [Newtonsoft.Json.JsonProperty("text", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Text { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface RenameProvider
    {
        ProviderResult<object> ProvideRenameEdits(ITextModel model, Position position, string newName, CancellationToken token);

        ProviderResult<object> ResolveRenameLocation(ITextModel model, Position position, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface SelectionRange
    {
        [Newtonsoft.Json.JsonProperty("range", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Range { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface SelectionRangeProvider
    {
        /// <summary>
        /// Provide ranges that should be selected from the given position.
        /// </summary>
        ProviderResult<SelectionRange[][]> ProvideSelectionRanges(ITextModel model, Position[] positions, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface SemanticTokens
    {
        [Newtonsoft.Json.JsonProperty("data", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        uint[] Data { get; set; }

        [Newtonsoft.Json.JsonProperty("resultId", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? ResultId { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface SemanticTokensEdit
    {
        [Newtonsoft.Json.JsonProperty("data", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        uint[]? Data { get; set; }

        [Newtonsoft.Json.JsonProperty("deleteCount", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double DeleteCount { get; set; }

        [Newtonsoft.Json.JsonProperty("start", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Start { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface SemanticTokensEdits
    {
        [Newtonsoft.Json.JsonProperty("edits", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        SemanticTokensEdit[] Edits { get; set; }

        [Newtonsoft.Json.JsonProperty("resultId", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? ResultId { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface SemanticTokensLegend
    {
        [Newtonsoft.Json.JsonProperty("tokenModifiers", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[] TokenModifiers { get; set; }

        [Newtonsoft.Json.JsonProperty("tokenTypes", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[] TokenTypes { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Signature help represents the signature of something
    /// callable. There can be multiple signatures but only one
    /// active and only one active parameter.
    /// </summary>
    interface SignatureHelp
    {
        /// <summary>
        /// The active parameter of the active signature.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("activeParameter", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ActiveParameter { get; set; }

        /// <summary>
        /// The active signature.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("activeSignature", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ActiveSignature { get; set; }

        /// <summary>
        /// One or more signatures.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("signatures", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        SignatureInformation[] Signatures { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface SignatureHelpContext
    {
        [Newtonsoft.Json.JsonProperty("activeSignatureHelp", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        SignatureHelp? ActiveSignatureHelp { get; set; }

        [Newtonsoft.Json.JsonProperty("isRetrigger", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IsRetrigger { get; set; }

        [Newtonsoft.Json.JsonProperty("triggerCharacter", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? TriggerCharacter { get; set; }

        [Newtonsoft.Json.JsonProperty("triggerKind", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        SignatureHelpTriggerKind TriggerKind { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The signature help provider interface defines the contract between extensions and
    /// the [parameter hints](https://code.visualstudio.com/docs/editor/intellisense)-feature.
    /// </summary>
    interface SignatureHelpProvider
    {
        [Newtonsoft.Json.JsonProperty("signatureHelpRetriggerCharacters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object? SignatureHelpRetriggerCharacters { get; set; }

        [Newtonsoft.Json.JsonProperty("signatureHelpTriggerCharacters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object? SignatureHelpTriggerCharacters { get; set; }

        /// <summary>
        /// Provide help for the signature at the given position and document.
        /// </summary>
        ProviderResult<SignatureHelpResult> ProvideSignatureHelp(ITextModel model, Position position, CancellationToken token, SignatureHelpContext context);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface SignatureHelpResult : IDisposable
    {
        [Newtonsoft.Json.JsonProperty("value", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        SignatureHelp Value { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// Represents the signature of something callable. A signature
    /// can have a label, like a function-name, a doc-comment, and
    /// a set of parameters.
    /// </summary>
    interface SignatureInformation
    {
        /// <summary>
        /// Index of the active parameter./// If provided, this is used in place of `SignatureHelp.activeSignature`.
        /// 
        /// </summary>
        [Newtonsoft.Json.JsonProperty("activeParameter", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? ActiveParameter { get; set; }

        /// <summary>
        /// The human-readable doc-comment of this signature. Will be shown
        /// in the UI but can be omitted.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IMarkdownString? Documentation { get; set; }

        /// <summary>
        /// The label of this signature. Will be shown in
        /// the UI.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("label", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Label { get; set; }

        /// <summary>
        /// The parameters of this signature.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parameters", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        ParameterInformation[] Parameters { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// A "manual" provider of tokens.
    /// </summary>
    interface TokensProvider
    {
        /// <summary>
        /// The initial state of a language. Will be the state passed in to tokenize the first line.
        /// </summary>
        IState GetInitialState();

        /// <summary>
        /// Tokenize a line given the state at the beginning of the line.
        /// </summary>
        ILineTokens Tokenize(string line, IState state);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    /// <summary>
    /// The type definition provider interface defines the contract between extensions and
    /// the go to type definition feature.
    /// </summary>
    interface TypeDefinitionProvider
    {
        /// <summary>
        /// Provide the type definition of the symbol at the given position and document.
        /// </summary>
        ProviderResult<Definition> ProvideTypeDefinition(ITextModel model, Position position, CancellationToken token);

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface WorkspaceEdit
    {
        [Newtonsoft.Json.JsonProperty("edits", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        WorkspaceFileEdit[] Edits { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface WorkspaceEditMetadata
    {
        [Newtonsoft.Json.JsonProperty("description", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? Description { get; set; }

        [Newtonsoft.Json.JsonProperty("label", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Label { get; set; }

        [Newtonsoft.Json.JsonProperty("needsConfirmation", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool NeedsConfirmation { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface WorkspaceFileEdit
    {
        [Newtonsoft.Json.JsonProperty("metadata", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        WorkspaceEditMetadata? Metadata { get; set; }

        [Newtonsoft.Json.JsonProperty("newUri", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri? NewUri { get; set; }

        [Newtonsoft.Json.JsonProperty("oldUri", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri? OldUri { get; set; }

        [Newtonsoft.Json.JsonProperty("options", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        WorkspaceFileEditOptions? Options { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface WorkspaceFileEditOptions
    {
        [Newtonsoft.Json.JsonProperty("copy", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Copy { get; set; }

        [Newtonsoft.Json.JsonProperty("folder", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Folder { get; set; }

        [Newtonsoft.Json.JsonProperty("ignoreIfExists", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? IgnoreIfExists { get; set; }

        [Newtonsoft.Json.JsonProperty("ignoreIfNotExists", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? IgnoreIfNotExists { get; set; }

        [Newtonsoft.Json.JsonProperty("maxSize", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? MaxSize { get; set; }

        [Newtonsoft.Json.JsonProperty("overwrite", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Overwrite { get; set; }

        [Newtonsoft.Json.JsonProperty("recursive", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? Recursive { get; set; }

        [Newtonsoft.Json.JsonProperty("skipTrashBin", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SkipTrashBin { get; set; }

    }
}

namespace Monaco.Languages
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Worker;
    using Monaco;

    interface WorkspaceTextEdit
    {
        [Newtonsoft.Json.JsonProperty("edit", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        TextEdit Edit { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        WorkspaceEditMetadata? Metadata { get; set; }

        [Newtonsoft.Json.JsonProperty("modelVersionId", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double? ModelVersionId { get; set; }

        [Newtonsoft.Json.JsonProperty("resource", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri Resource { get; set; }

    }
}

namespace Monaco.Worker
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco;

    interface IMirrorModel
    {
        [Newtonsoft.Json.JsonProperty("uri", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri Uri { get; set; }

        [Newtonsoft.Json.JsonProperty("version", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Version { get; set; }

        string GetValue();

    }
}

namespace Monaco.Worker
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco;

    interface IWorkerContext<H>
    {
        /// <summary>
        /// A proxy to the main thread host object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("host", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        H Host { get; set; }

        /// <summary>
        /// Get all available mirror models in this worker.
        /// </summary>
        IMirrorModel[] GetMirrorModels();

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    /// <summary>
    /// Virtual Key Codes, the value does not hold any inherent meaning.
    /// Inspired somewhat from https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
    /// But these are "more general", as they should work across browsers &amp; OS`s.
    /// </summary>
    enum KeyCode
    {
        ABNTC1 = 110,
        ABNTC2 = 111,
        Alt = 6,
        Backspace = 1,
        CapsLock = 8,
        ContextMenu = 58,
        Ctrl = 5,
        Delete = 20,
        DownArrow = 18,
        End = 13,
        Enter = 3,
        Escape = 9,
        F1 = 59,
        F10 = 68,
        F11 = 69,
        F12 = 70,
        F13 = 71,
        F14 = 72,
        F15 = 73,
        F16 = 74,
        F17 = 75,
        F18 = 76,
        F19 = 77,
        F2 = 60,
        F3 = 61,
        F4 = 62,
        F5 = 63,
        F6 = 64,
        F7 = 65,
        F8 = 66,
        F9 = 67,
        Home = 14,
        Insert = 19,
        KEY0 = 21,
        KEY1 = 22,
        KEY2 = 23,
        KEY3 = 24,
        KEY4 = 25,
        KEY5 = 26,
        KEY6 = 27,
        KEY7 = 28,
        KEY8 = 29,
        KEY9 = 30,
        KEYA = 31,
        KEYB = 32,
        KEYC = 33,
        KEYD = 34,
        KEYE = 35,
        KEYF = 36,
        KEYG = 37,
        KEYH = 38,
        KEYI = 39,
        /// <summary>
        /// Cover all key codes when IME is processing input.
        /// </summary>
        KEYINCOMPOSITION = 109,
        KEYJ = 40,
        KEYK = 41,
        KEYL = 42,
        KEYM = 43,
        KEYN = 44,
        KEYO = 45,
        KEYP = 46,
        KEYQ = 47,
        KEYR = 48,
        KEYS = 49,
        KEYT = 50,
        KEYU = 51,
        KEYV = 52,
        KEYW = 53,
        KEYX = 54,
        KEYY = 55,
        KEYZ = 56,
        LeftArrow = 15,
        /// <summary>
        /// Placed last to cover the length of the enum.
        /// Please do not depend on this value!
        /// </summary>
        MAXVALUE = 112,
        Meta = 57,
        NUMPAD0 = 93,
        NUMPAD1 = 94,
        NUMPAD2 = 95,
        NUMPAD3 = 96,
        NUMPAD4 = 97,
        NUMPAD5 = 98,
        NUMPAD6 = 99,
        NUMPAD7 = 100,
        NUMPAD8 = 101,
        NUMPAD9 = 102,
        NUMPADADD = 104,
        NUMPADDECIMAL = 107,
        NUMPADDIVIDE = 108,
        NUMPADMULTIPLY = 103,
        NUMPADSEPARATOR = 105,
        NUMPADSUBTRACT = 106,
        NumLock = 78,
        /// <summary>
        /// Either the angle bracket key or the backslash key on the RT 102-key keyboard.
        /// </summary>
        OEM102 = 92,
        /// <summary>
        /// Used for miscellaneous characters; it can vary by keyboard.
        /// </summary>
        OEM8 = 91,
        PageDown = 12,
        PageUp = 11,
        PauseBreak = 7,
        RightArrow = 17,
        ScrollLock = 79,
        Shift = 4,
        Space = 10,
        Tab = 2,
        /// <summary>
        /// Used for miscellaneous characters; it can vary by keyboard.
        /// For the US standard keyboard, the '\|' key
        /// </summary>
        USBACKSLASH = 88,
        /// <summary>
        /// Used for miscellaneous characters; it can vary by keyboard.
        /// For the US standard keyboard, the '`~' key
        /// </summary>
        USBACKTICK = 86,
        /// <summary>
        /// Used for miscellaneous characters; it can vary by keyboard.
        /// For the US standard keyboard, the ']}' key
        /// </summary>
        USCLOSESQUAREBRACKET = 89,
        /// <summary>
        /// For any country/region, the ',' key
        /// For the US standard keyboard, the ',&lt;' key
        /// </summary>
        USCOMMA = 82,
        /// <summary>
        /// For any country/region, the '.' key
        /// For the US standard keyboard, the '.&gt;' key
        /// </summary>
        USDOT = 84,
        /// <summary>
        /// For any country/region, the '+' key
        /// For the US standard keyboard, the '=+' key
        /// </summary>
        USEQUAL = 81,
        /// <summary>
        /// For any country/region, the '-' key
        /// For the US standard keyboard, the '-_' key
        /// </summary>
        USMINUS = 83,
        /// <summary>
        /// Used for miscellaneous characters; it can vary by keyboard.
        /// For the US standard keyboard, the '[{' key
        /// </summary>
        USOPENSQUAREBRACKET = 87,
        /// <summary>
        /// Used for miscellaneous characters; it can vary by keyboard.
        /// For the US standard keyboard, the ''"' key
        /// </summary>
        USQUOTE = 90,
        /// <summary>
        /// Used for miscellaneous characters; it can vary by keyboard.
        /// For the US standard keyboard, the ';:' key
        /// </summary>
        USSEMICOLON = 80,
        /// <summary>
        /// Used for miscellaneous characters; it can vary by keyboard.
        /// For the US standard keyboard, the '/?' key
        /// </summary>
        USSLASH = 85,
        /// <summary>
        /// Placed first to cover the 0 value of the enum.
        /// </summary>
        Unknown = 0,
        UpArrow = 16
    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    enum MarkerSeverity
    {
        Error = 8,
        Hint = 1,
        Info = 2,
        Warning = 4
    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    enum MarkerTag
    {
        Deprecated = 2,
        Unnecessary = 1
    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    /// <summary>
    /// The direction of a selection.
    /// </summary>
    enum SelectionDirection
    {
        /// <summary>
        /// The selection starts above where it ends.
        /// </summary>
        LTR = 0,
        /// <summary>
        /// The selection starts below where it ends.
        /// </summary>
        RTL = 1
    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    class CancellationTokenSource
    {
        public CancellationTokenSource(CancellationToken parent) => throw new System.NotImplementedException();

        [Newtonsoft.Json.JsonProperty("token", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CancellationToken Token { get => throw new System.NotImplementedException(); }

        public void Cancel() => throw new System.NotImplementedException();

        public void Dispose(bool cancel) => throw new System.NotImplementedException();

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    /// <summary>
    /// A helper that allows to emit and listen to typed events
    /// </summary>
    class Emitter<T>
    {
        public Emitter() => throw new System.NotImplementedException();

        [Newtonsoft.Json.JsonProperty("event", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IEvent<T> Event { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        public void Dispose() => throw new System.NotImplementedException();

        public void Fire(T @event) => throw new System.NotImplementedException();

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    class KeyMod
    {
        public KeyMod() => throw new System.NotImplementedException();

        [Newtonsoft.Json.JsonProperty("Alt", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        static double Alt { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("CtrlCmd", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        static double CtrlCmd { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("Shift", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        static double Shift { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("WinCtrl", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        static double WinCtrl { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        static double Chord(double firstPart, double secondPart) => throw new System.NotImplementedException();

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    /// <summary>
    /// A position in the editor.
    /// </summary>
    class Position
    {
        public Position(double lineNumber, double column) => throw new System.NotImplementedException();

        /// <summary>
        /// column (the first character in a line is between column 1 and column 2)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("column", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double Column { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// line number (starts at 1)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double LineNumber { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Clone this position.
        /// </summary>
        public Position Clone() => throw new System.NotImplementedException();

        /// <summary>
        /// Derive a new position from this position.
        /// </summary>
        public Position Delta(double deltaLineNumber, double deltaColumn) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if this position equals other position
        /// </summary>
        public bool Equals(IPosition other) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if this position is before other position.
        /// If the two positions are equal, the result will be false.
        /// </summary>
        public bool IsBefore(IPosition other) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if this position is before other position.
        /// If the two positions are equal, the result will be true.
        /// </summary>
        public bool IsBeforeOrEqual(IPosition other) => throw new System.NotImplementedException();

        /// <summary>
        /// Convert to a human-readable representation.
        /// </summary>
        public string ToString() => throw new System.NotImplementedException();

        /// <summary>
        /// Create a new position from this position.
        /// </summary>
        public Position With(double newLineNumber, double newColumn) => throw new System.NotImplementedException();

        /// <summary>
        /// A function that compares positions, useful for sorting
        /// </summary>
        static double Compare(IPosition a, IPosition b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if position `a` equals position `b`
        /// </summary>
        static bool Equals(IPosition a, IPosition b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if position `a` is before position `b`.
        /// If the two positions are equal, the result will be false.
        /// </summary>
        static bool IsBefore(IPosition a, IPosition b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if position `a` is before position `b`.
        /// If the two positions are equal, the result will be true.
        /// </summary>
        static bool IsBeforeOrEqual(IPosition a, IPosition b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `obj` is an `IPosition`.
        /// </summary>
        static object IsIPosition(object obj) => throw new System.NotImplementedException();

        /// <summary>
        /// Create a `Position` from an `IPosition`.
        /// </summary>
        static Position Lift(IPosition pos) => throw new System.NotImplementedException();

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    /// <summary>
    /// A range in the editor. (startLineNumber,startColumn) is &lt;= (endLineNumber,endColumn)
    /// </summary>
    class Range
    {
        public Range(double startLineNumber, double startColumn, double endLineNumber, double endColumn) => throw new System.NotImplementedException();

        /// <summary>
        /// Column on which the range ends in line `endLineNumber`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double EndColumn { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Line number on which the range ends.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double EndLineNumber { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Column on which the range starts in line `startLineNumber` (starts at 1).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double StartColumn { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Line number on which the range starts (starts at 1).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double StartLineNumber { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Create a new empty range using this range's start position.
        /// </summary>
        public Range CollapseToStart() => throw new System.NotImplementedException();

        /// <summary>
        /// Test if position is in this range. If the position is at the edges, will return true.
        /// </summary>
        public bool ContainsPosition(IPosition position) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if range is in this range. If the range is equal to this range, will return true.
        /// </summary>
        public bool ContainsRange(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if this range equals other.
        /// </summary>
        public bool EqualsRange(IRange other) => throw new System.NotImplementedException();

        /// <summary>
        /// Return the end position (which will be after or equal to the start position)
        /// </summary>
        public Position GetEndPosition() => throw new System.NotImplementedException();

        /// <summary>
        /// Return the start position (which will be before or equal to the end position)
        /// </summary>
        public Position GetStartPosition() => throw new System.NotImplementedException();

        /// <summary>
        /// A intersection of the two ranges.
        /// </summary>
        public Range IntersectRanges(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if this range is empty.
        /// </summary>
        public bool IsEmpty() => throw new System.NotImplementedException();

        /// <summary>
        /// A reunion of the two ranges.
        /// The smallest position will be used as the start point, and the largest one as the end point.
        /// </summary>
        public Range PlusRange(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.
        /// </summary>
        public Range SetEndPosition(double endLineNumber, double endColumn) => throw new System.NotImplementedException();

        /// <summary>
        /// Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.
        /// </summary>
        public Range SetStartPosition(double startLineNumber, double startColumn) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.
        /// </summary>
        public bool StrictContainsRange(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Transform to a user presentable string representation.
        /// </summary>
        public string ToString() => throw new System.NotImplementedException();

        /// <summary>
        /// Test if the two ranges are intersecting. If the ranges are touching it returns true.
        /// </summary>
        static bool AreIntersecting(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if the two ranges are touching in any way.
        /// </summary>
        static bool AreIntersectingOrTouching(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// Create a new empty range using this range's start position.
        /// </summary>
        static Range CollapseToStart(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// A function that compares ranges, useful for sorting ranges
        /// It will first compare ranges on the endPosition and then on the startPosition
        /// </summary>
        static double CompareRangesUsingEnds(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// A function that compares ranges, useful for sorting ranges
        /// It will first compare ranges on the startPosition and then on the endPosition
        /// </summary>
        static double CompareRangesUsingStarts(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `position` is in `range`. If the position is at the edges, will return true.
        /// </summary>
        static bool ContainsPosition(IRange range, IPosition position) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `otherRange` is in `range`. If the ranges are equal, will return true.
        /// </summary>
        static bool ContainsRange(IRange range, IRange otherRange) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if range `a` equals `b`.
        /// </summary>
        static bool EqualsRange(IRange a, IRange b) => throw new System.NotImplementedException();

        static Range FromPositions(IPosition start, IPosition end) => throw new System.NotImplementedException();

        /// <summary>
        /// Return the end position (which will be after or equal to the start position)
        /// </summary>
        static Position GetEndPosition(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Return the start position (which will be before or equal to the end position)
        /// </summary>
        static Position GetStartPosition(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// A intersection of the two ranges.
        /// </summary>
        static Range IntersectRanges(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `range` is empty.
        /// </summary>
        static bool IsEmpty(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `obj` is an `IRange`.
        /// </summary>
        static object IsIRange(object obj) => throw new System.NotImplementedException();

        /// <summary>
        /// Create a `Range` from an `IRange`.
        /// </summary>
        static string Lift(string range) => throw new System.NotImplementedException();

        static Range Lift(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// A reunion of the two ranges.
        /// The smallest position will be used as the start point, and the largest one as the end point.
        /// </summary>
        static Range PlusRange(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if the range spans multiple lines.
        /// </summary>
        static bool SpansMultipleLines(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `otherRange` is strinctly in `range` (must start after, and end before). If the ranges are equal, will return false.
        /// </summary>
        static bool StrictContainsRange(IRange range, IRange otherRange) => throw new System.NotImplementedException();

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    /// <summary>
    /// A selection in the editor.
    /// The selection is a range that has an orientation.
    /// </summary>
    class Selection : Range
    {
        public Selection(double selectionStartLineNumber, double selectionStartColumn, double positionLineNumber, double positionColumn) => throw new System.NotImplementedException();

        /// <summary>
        /// Column on which the range ends in line `endLineNumber`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double EndColumn { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Line number on which the range ends.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double EndLineNumber { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// The column on `positionLineNumber` where the selection has ended.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("positionColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double PositionColumn { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// The line number on which the selection has ended.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("positionLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double PositionLineNumber { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// The column on `selectionStartLineNumber` where the selection has started.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectionStartColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double SelectionStartColumn { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// The line number on which the selection has started.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectionStartLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double SelectionStartLineNumber { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Column on which the range starts in line `startLineNumber` (starts at 1).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double StartColumn { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Line number on which the range starts (starts at 1).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double StartLineNumber { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Create a new empty range using this range's start position.
        /// </summary>
        public Range CollapseToStart() => throw new System.NotImplementedException();

        /// <summary>
        /// Test if position is in this range. If the position is at the edges, will return true.
        /// </summary>
        public bool ContainsPosition(IPosition position) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if range is in this range. If the range is equal to this range, will return true.
        /// </summary>
        public bool ContainsRange(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if this range equals other.
        /// </summary>
        public bool EqualsRange(IRange other) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if equals other selection.
        /// </summary>
        public bool EqualsSelection(ISelection other) => throw new System.NotImplementedException();

        /// <summary>
        /// Get directions (LTR or RTL).
        /// </summary>
        public SelectionDirection GetDirection() => throw new System.NotImplementedException();

        /// <summary>
        /// Return the end position (which will be after or equal to the start position)
        /// </summary>
        public Position GetEndPosition() => throw new System.NotImplementedException();

        /// <summary>
        /// Get the position at `positionLineNumber` and `positionColumn`.
        /// </summary>
        public Position GetPosition() => throw new System.NotImplementedException();

        /// <summary>
        /// Return the start position (which will be before or equal to the end position)
        /// </summary>
        public Position GetStartPosition() => throw new System.NotImplementedException();

        /// <summary>
        /// A intersection of the two ranges.
        /// </summary>
        public Range IntersectRanges(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if this range is empty.
        /// </summary>
        public bool IsEmpty() => throw new System.NotImplementedException();

        /// <summary>
        /// A reunion of the two ranges.
        /// The smallest position will be used as the start point, and the largest one as the end point.
        /// </summary>
        public Range PlusRange(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Create a new selection with a different `positionLineNumber` and `positionColumn`.
        /// </summary>
        public Selection SetEndPosition(double endLineNumber, double endColumn) => throw new System.NotImplementedException();

        /// <summary>
        /// Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.
        /// </summary>
        public Selection SetStartPosition(double startLineNumber, double startColumn) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.
        /// </summary>
        public bool StrictContainsRange(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Transform to a human-readable representation.
        /// </summary>
        public string ToString() => throw new System.NotImplementedException();

        /// <summary>
        /// Test if the two ranges are intersecting. If the ranges are touching it returns true.
        /// </summary>
        static bool AreIntersecting(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if the two ranges are touching in any way.
        /// </summary>
        static bool AreIntersectingOrTouching(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// Create a new empty range using this range's start position.
        /// </summary>
        static Range CollapseToStart(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// A function that compares ranges, useful for sorting ranges
        /// It will first compare ranges on the endPosition and then on the startPosition
        /// </summary>
        static double CompareRangesUsingEnds(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// A function that compares ranges, useful for sorting ranges
        /// It will first compare ranges on the startPosition and then on the endPosition
        /// </summary>
        static double CompareRangesUsingStarts(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `position` is in `range`. If the position is at the edges, will return true.
        /// </summary>
        static bool ContainsPosition(IRange range, IPosition position) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `otherRange` is in `range`. If the ranges are equal, will return true.
        /// </summary>
        static bool ContainsRange(IRange range, IRange otherRange) => throw new System.NotImplementedException();

        /// <summary>
        /// Create with a direction.
        /// </summary>
        static Selection CreateWithDirection(double startLineNumber, double startColumn, double endLineNumber, double endColumn, SelectionDirection direction) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if range `a` equals `b`.
        /// </summary>
        static bool EqualsRange(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// Create a `Selection` from one or two positions
        /// </summary>
        static Selection FromPositions(IPosition start, IPosition end) => throw new System.NotImplementedException();

        /// <summary>
        /// Return the end position (which will be after or equal to the start position)
        /// </summary>
        static Position GetEndPosition(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Return the start position (which will be before or equal to the end position)
        /// </summary>
        static Position GetStartPosition(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// A intersection of the two ranges.
        /// </summary>
        static Range IntersectRanges(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `range` is empty.
        /// </summary>
        static bool IsEmpty(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `obj` is an `IRange`.
        /// </summary>
        static object IsIRange(object obj) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `obj` is an `ISelection`.
        /// </summary>
        static object IsISelection(object obj) => throw new System.NotImplementedException();

        /// <summary>
        /// Create a `Range` from an `IRange`.
        /// </summary>
        static string Lift(string range) => throw new System.NotImplementedException();

        static Range Lift(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Create a `Selection` from an `ISelection`.
        /// </summary>
        static Selection LiftSelection(ISelection sel) => throw new System.NotImplementedException();

        /// <summary>
        /// A reunion of the two ranges.
        /// The smallest position will be used as the start point, and the largest one as the end point.
        /// </summary>
        static Range PlusRange(IRange a, IRange b) => throw new System.NotImplementedException();

        /// <summary>
        /// `a` equals `b`.
        /// </summary>
        static bool SelectionsArrEqual(ISelection[] a, ISelection[] b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if the two selections are equal.
        /// </summary>
        static bool SelectionsEqual(ISelection a, ISelection b) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if the range spans multiple lines.
        /// </summary>
        static bool SpansMultipleLines(IRange range) => throw new System.NotImplementedException();

        /// <summary>
        /// Test if `otherRange` is strinctly in `range` (must start after, and end before). If the ranges are equal, will return false.
        /// </summary>
        static bool StrictContainsRange(IRange range, IRange otherRange) => throw new System.NotImplementedException();

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    class Token
    {
        public Token(double offset, string type, string language) => throw new System.NotImplementedException();

        [Newtonsoft.Json.JsonProperty("_tokenBrand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public void TokenBrand { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("language", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Language { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("offset", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double Offset { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        [Newtonsoft.Json.JsonProperty("type", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        public string ToString() => throw new System.NotImplementedException();

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    /// <summary>
    /// Uniform Resource Identifier (Uri) http://tools.ietf.org/html/rfc3986.
    /// This class is a simple parser which creates the basic component parts
    /// (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation
    /// and encoding./// ```txt
    ///       foo://example.com:8042/over/there?name=ferret#nose
    ///       \_/   \______________/\_________/ \_________/ \__/
    ///        |           |            |            |        |
    ///     scheme     authority       path        query   fragment
    ///        |   _____________________|__
    ///       / \ /                        \
    ///       urn:example:animal:ferret:nose
    /// ```
    /// 
    /// </summary>
    class Uri : UriComponents
    {
        public Uri() => throw new System.NotImplementedException();

        /// <summary>
        /// authority is the 'www.msft.com' part of 'http://www.msft.com/some/path?query#fragment'.
        /// The part between the first double slashes and the next slash.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authority", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Authority { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// fragment is the 'fragment' part of 'http://www.msft.com/some/path?query#fragment'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fragment", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fragment { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// path is the '/some/path' part of 'http://www.msft.com/some/path?query#fragment'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("path", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// query is the 'query' part of 'http://www.msft.com/some/path?query#fragment'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("query", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Query { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// scheme is the 'http' part of 'http://www.msft.com/some/path?query#fragment'.
        /// The part before the first colon.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scheme", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Scheme { get => throw new System.NotImplementedException(); set => throw new System.NotImplementedException(); }

        /// <summary>
        /// Returns a string representing the corresponding file system path of this Uri.
        /// Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
        /// platform specific path separator./// * Will *not* validate the path for invalid characters and semantics.
        /// * Will *not* look at the scheme of this Uri.
        /// * The result shall *not* be used for display purposes but for accessing a file on disk.
        /// 
        /// 
        /// The *difference* to `Uri#path` is the use of the platform specific separator and the handling
        /// of UNC paths. See the below sample of a file-uri with an authority (UNC path).
        /// 
        /// ```ts
        /// const u = Uri.parse('file://server/c$/folder/file.txt')
        /// u.authority === 'server'
        /// u.path === '/shares/c$/file.txt'
        /// u.fsPath === '\\server\c$\folder\file.txt'
        /// ```
        /// 
        /// Using `Uri#path` to read a file (using fs-apis) would not be enough because parts of the path,
        /// namely the server name, would be missing. Therefore `Uri#fsPath` exists - it's sugar to ease working
        /// with URIs that represent files on disk (`file` scheme).
        /// 
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fsPath", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FsPath { get => throw new System.NotImplementedException(); }

        public UriComponents ToJSON() => throw new System.NotImplementedException();

        /// <summary>
        /// Creates a string representation for this Uri. It's guaranteed that calling
        /// `Uri.parse` with the result of this function creates an Uri which is equal
        /// to this Uri./// * The result shall *not* be used for display purposes but for externalization or transport.
        /// * The result will be encoded using the percentage encoding and encoding happens mostly
        /// ignore the scheme-specific encoding rules.
        /// 
        /// </summary>
        public string ToString(bool skipEncoding) => throw new System.NotImplementedException();

        public Uri With(TypedocConverter.GeneratedTypes.LiteralStringAuthorityStringFragmentStringPathStringQueryStringScheme change) => throw new System.NotImplementedException();

        /// <summary>
        /// Creates a new Uri from a file system path, e.g. `c:\my\files`,
        /// `/usr/home`, or `\\server\share\some\path`./// The *difference* between `Uri#parse` and `Uri#file` is that the latter treats the argument
        /// as path, not as stringified-uri. E.g. `Uri.file(path)` is **not the same as**
        /// `Uri.parse('file://' + path)` because the path might contain characters that are
        /// interpreted (# and ?). See the following sample:
        /// ```ts
        /// const good = Uri.file('/coding/c#/project1');
        /// good.scheme === 'file';
        /// good.path === '/coding/c#/project1';
        /// good.fragment === '';
        /// const bad = Uri.parse('file://' + '/coding/c#/project1');
        /// bad.scheme === 'file';
        /// bad.path === '/coding/c'; // path is now broken
        /// bad.fragment === '/project1';
        /// ```
        /// 
        /// </summary>
        static Uri File(string path) => throw new System.NotImplementedException();

        static Uri From(TypedocConverter.GeneratedTypes.LiteralStringAuthorityStringFragmentStringPathStringQueryStringScheme components) => throw new System.NotImplementedException();

        static object IsUri(object thing) => throw new System.NotImplementedException();

        /// <summary>
        /// Join a Uri path with path fragments and normalizes the resulting path.
        /// </summary>
        /// <returns>
        /// The resulting Uri.
        /// 
        /// </returns>
        static Uri JoinPath(Uri uri, string[] pathFragment) => throw new System.NotImplementedException();

        /// <summary>
        /// Creates a new Uri from a string, e.g. `http://www.msft.com/some/path`,
        /// `file:///usr/home`, or `scheme:with/path`.
        /// </summary>
        static Uri Parse(string value, bool _strict) => throw new System.NotImplementedException();

        static Uri Revive(Uri data) => throw new System.NotImplementedException();

        static Uri Revive(Uri data) => throw new System.NotImplementedException();

        static Uri Revive(Uri data) => throw new System.NotImplementedException();

        static Uri Revive(Uri data) => throw new System.NotImplementedException();

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    interface CancellationToken
    {
        /// <summary>
        /// An event which fires when cancellation is requested. This event
        /// only ever fires `once` as cancellation can only happen once. Listeners
        /// that are registered after cancellation will be called (next event loop run),
        /// but also only once.
        /// </summary>
        event System.Func<System.Func<object, object>, object, IDisposable[], IDisposable> OnCancellationRequested;

        /// <summary>
        /// A flag signalling is cancellation has been requested.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isCancellationRequested", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool IsCancellationRequested { get; set; }

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    interface Environment
    {
        [Newtonsoft.Json.JsonProperty("baseUrl", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string? BaseUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("globalAPI", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? GlobalAPI { get; set; }

        Worker GetWorker(string workerId, string label);

        string GetWorkerUrl(string workerId, string label);

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    interface IDisposable
    {
        void Dispose();

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    interface IEvent<T>
    {
    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    interface IKeyboardEvent
    {
        [Newtonsoft.Json.JsonProperty("_standardKeyboardEventBrand", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string StandardKeyboardEventBrand { get; set; }

        [Newtonsoft.Json.JsonProperty("altKey", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool AltKey { get; set; }

        [Newtonsoft.Json.JsonProperty("browserEvent", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        KeyboardEvent BrowserEvent { get; set; }

        [Newtonsoft.Json.JsonProperty("code", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Code { get; set; }

        [Newtonsoft.Json.JsonProperty("ctrlKey", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool CtrlKey { get; set; }

        [Newtonsoft.Json.JsonProperty("keyCode", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        KeyCode KeyCode { get; set; }

        [Newtonsoft.Json.JsonProperty("metaKey", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool MetaKey { get; set; }

        [Newtonsoft.Json.JsonProperty("shiftKey", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool ShiftKey { get; set; }

        [Newtonsoft.Json.JsonProperty("target", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        HTMLElement Target { get; set; }

        bool Equals(double keybinding);

        void PreventDefault();

        void StopPropagation();

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    interface IMarkdownString
    {
        [Newtonsoft.Json.JsonProperty("isTrusted", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? IsTrusted { get; set; }

        [Newtonsoft.Json.JsonProperty("supportThemeIcons", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool? SupportThemeIcons { get; set; }

        [Newtonsoft.Json.JsonProperty("uris", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        System.Collections.Generic.IDictionary<string, UriComponents>? Uris { get; set; }

        [Newtonsoft.Json.JsonProperty("value", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Value { get; set; }

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    interface IMouseEvent
    {
        [Newtonsoft.Json.JsonProperty("altKey", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool AltKey { get; set; }

        [Newtonsoft.Json.JsonProperty("browserEvent", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        MouseEvent BrowserEvent { get; set; }

        [Newtonsoft.Json.JsonProperty("buttons", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Buttons { get; set; }

        [Newtonsoft.Json.JsonProperty("ctrlKey", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool CtrlKey { get; set; }

        [Newtonsoft.Json.JsonProperty("detail", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Detail { get; set; }

        [Newtonsoft.Json.JsonProperty("leftButton", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool LeftButton { get; set; }

        [Newtonsoft.Json.JsonProperty("metaKey", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool MetaKey { get; set; }

        [Newtonsoft.Json.JsonProperty("middleButton", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool MiddleButton { get; set; }

        [Newtonsoft.Json.JsonProperty("posx", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Posx { get; set; }

        [Newtonsoft.Json.JsonProperty("posy", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Posy { get; set; }

        [Newtonsoft.Json.JsonProperty("rightButton", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool RightButton { get; set; }

        [Newtonsoft.Json.JsonProperty("shiftKey", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool ShiftKey { get; set; }

        [Newtonsoft.Json.JsonProperty("target", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        HTMLElement Target { get; set; }

        [Newtonsoft.Json.JsonProperty("timestamp", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Timestamp { get; set; }

        void PreventDefault();

        void StopPropagation();

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    /// <summary>
    /// A position in the editor. This interface is suitable for serialization.
    /// </summary>
    interface IPosition
    {
        /// <summary>
        /// column (the first character in a line is between column 1 and column 2)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("column", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Column { get; set; }

        /// <summary>
        /// line number (starts at 1)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double LineNumber { get; set; }

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    /// <summary>
    /// A range in the editor. This interface is suitable for serialization.
    /// </summary>
    interface IRange
    {
        /// <summary>
        /// Column on which the range ends in line `endLineNumber`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double EndColumn { get; set; }

        /// <summary>
        /// Line number on which the range ends.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double EndLineNumber { get; set; }

        /// <summary>
        /// Column on which the range starts in line `startLineNumber` (starts at 1).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double StartColumn { get; set; }

        /// <summary>
        /// Line number on which the range starts (starts at 1).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double StartLineNumber { get; set; }

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    interface IScrollEvent
    {
        [Newtonsoft.Json.JsonProperty("scrollHeight", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ScrollHeight { get; set; }

        [Newtonsoft.Json.JsonProperty("scrollHeightChanged", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool ScrollHeightChanged { get; set; }

        [Newtonsoft.Json.JsonProperty("scrollLeft", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ScrollLeft { get; set; }

        [Newtonsoft.Json.JsonProperty("scrollLeftChanged", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool ScrollLeftChanged { get; set; }

        [Newtonsoft.Json.JsonProperty("scrollTop", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ScrollTop { get; set; }

        [Newtonsoft.Json.JsonProperty("scrollTopChanged", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool ScrollTopChanged { get; set; }

        [Newtonsoft.Json.JsonProperty("scrollWidth", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double ScrollWidth { get; set; }

        [Newtonsoft.Json.JsonProperty("scrollWidthChanged", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool ScrollWidthChanged { get; set; }

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    /// <summary>
    /// A selection in the editor.
    /// The selection is a range that has an orientation.
    /// </summary>
    interface ISelection
    {
        /// <summary>
        /// The column on `positionLineNumber` where the selection has ended.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("positionColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double PositionColumn { get; set; }

        /// <summary>
        /// The line number on which the selection has ended.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("positionLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double PositionLineNumber { get; set; }

        /// <summary>
        /// The column on `selectionStartLineNumber` where the selection has started.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectionStartColumn", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double SelectionStartColumn { get; set; }

        /// <summary>
        /// The line number on which the selection has started.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectionStartLineNumber", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double SelectionStartLineNumber { get; set; }

    }
}

namespace Monaco
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;

    interface UriComponents
    {
        [Newtonsoft.Json.JsonProperty("authority", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Authority { get; set; }

        [Newtonsoft.Json.JsonProperty("fragment", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Fragment { get; set; }

        [Newtonsoft.Json.JsonProperty("path", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Path { get; set; }

        [Newtonsoft.Json.JsonProperty("query", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Query { get; set; }

        [Newtonsoft.Json.JsonProperty("scheme", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Scheme { get; set; }

    }
}

namespace TypedocConverter.GeneratedTypes
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface LiteralDoubleHeightDoubleLeftDoubleTop
    {
        [Newtonsoft.Json.JsonProperty("height", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Height { get; set; }

        [Newtonsoft.Json.JsonProperty("left", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Left { get; set; }

        [Newtonsoft.Json.JsonProperty("top", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        double Top { get; set; }

    }
}

namespace TypedocConverter.GeneratedTypes
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface LiteralIDocCommentDocComment
    {
        [Newtonsoft.Json.JsonProperty("docComment", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IDocComment DocComment { get; set; }

    }
}

namespace TypedocConverter.GeneratedTypes
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface LiteralIRangeInsertIRangeReplace
    {
        [Newtonsoft.Json.JsonProperty("insert", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Insert { get; set; }

        [Newtonsoft.Json.JsonProperty("replace", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        IRange Replace { get; set; }

    }
}

namespace TypedocConverter.GeneratedTypes
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface LiteralStringAuthorityStringFragmentStringPathStringQueryStringScheme
    {
        [Newtonsoft.Json.JsonProperty("authority", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Authority { get; set; }

        [Newtonsoft.Json.JsonProperty("fragment", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Fragment { get; set; }

        [Newtonsoft.Json.JsonProperty("path", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Path { get; set; }

        [Newtonsoft.Json.JsonProperty("query", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Query { get; set; }

        [Newtonsoft.Json.JsonProperty("scheme", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Scheme { get; set; }

    }
}

namespace TypedocConverter.GeneratedTypes
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface LiteralStringContentStringFilePath
    {
        [Newtonsoft.Json.JsonProperty("content", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Content { get; set; }

        [Newtonsoft.Json.JsonProperty("filePath", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string FilePath { get; set; }

    }
}

namespace TypedocConverter.GeneratedTypes
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface LiteralStringLineEndingBoolPreserveBOM
    {
        [Newtonsoft.Json.JsonProperty("lineEnding", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string LineEnding { get; set; }

        [Newtonsoft.Json.JsonProperty("preserveBOM", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        bool PreserveBOM { get; set; }

    }
}

namespace TypedocConverter.GeneratedTypes
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface LiteralSystemArrayFileMatchObjectSchemaStringUri
    {
        [Newtonsoft.Json.JsonProperty("fileMatch", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string[] FileMatch { get; set; }

        [Newtonsoft.Json.JsonProperty("schema", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        object Schema { get; set; }

        [Newtonsoft.Json.JsonProperty("uri", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Uri { get; set; }

    }
}

namespace TypedocConverter.GeneratedTypes
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface LiteralUnionStringStringStringArgumentsInColorFunctionUnionStringStringStringBoxModelUnionStringStringStringCompatibleVendorPrefixesUnionStringStringStringDuplicatePropertiesUnionStringStringStringEmptyRulesUnionStringStringStringFloatUnionStringStringStringFontFacePropertiesUnionStringStringStringHexColorLengthUnionStringStringStringIdSelectorUnionStringStringStringIeHackUnionStringStringStringImportStatementUnionStringStringStringImportantUnionStringStringStringPropertyIgnoredDueToDisplayUnionStringStringStringUniversalSelectorUnionStringStringStringUnknownPropertiesUnionStringStringStringUnknownVendorSpecificPropertiesUnionStringStringStringVendorPrefixUnionStringStringStringZeroUnits
    {
        [Newtonsoft.Json.JsonProperty("argumentsInColorFunction", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string ArgumentsInColorFunction { get; set; }

        [Newtonsoft.Json.JsonProperty("boxModel", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string BoxModel { get; set; }

        [Newtonsoft.Json.JsonProperty("compatibleVendorPrefixes", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string CompatibleVendorPrefixes { get; set; }

        [Newtonsoft.Json.JsonProperty("duplicateProperties", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string DuplicateProperties { get; set; }

        [Newtonsoft.Json.JsonProperty("emptyRules", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string EmptyRules { get; set; }

        [Newtonsoft.Json.JsonProperty("float", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Float { get; set; }

        [Newtonsoft.Json.JsonProperty("fontFaceProperties", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string FontFaceProperties { get; set; }

        [Newtonsoft.Json.JsonProperty("hexColorLength", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string HexColorLength { get; set; }

        [Newtonsoft.Json.JsonProperty("idSelector", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string IdSelector { get; set; }

        [Newtonsoft.Json.JsonProperty("ieHack", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string IeHack { get; set; }

        [Newtonsoft.Json.JsonProperty("importStatement", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string ImportStatement { get; set; }

        [Newtonsoft.Json.JsonProperty("important", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Important { get; set; }

        [Newtonsoft.Json.JsonProperty("propertyIgnoredDueToDisplay", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string PropertyIgnoredDueToDisplay { get; set; }

        [Newtonsoft.Json.JsonProperty("universalSelector", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string UniversalSelector { get; set; }

        [Newtonsoft.Json.JsonProperty("unknownProperties", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string UnknownProperties { get; set; }

        [Newtonsoft.Json.JsonProperty("unknownVendorSpecificProperties", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string UnknownVendorSpecificProperties { get; set; }

        [Newtonsoft.Json.JsonProperty("vendorPrefix", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string VendorPrefix { get; set; }

        [Newtonsoft.Json.JsonProperty("zeroUnits", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string ZeroUnits { get; set; }

    }
}

namespace TypedocConverter.GeneratedTypes
{
    using Monaco.Editor;
    using Monaco.Languages.Css;
    using Monaco.Languages.Html;
    using Monaco.Languages.Json;
    using Monaco.Languages.Typescript;
    using Monaco.Languages;
    using Monaco.Worker;
    using Monaco;

    interface LiteralUriTargetStringValue
    {
        [Newtonsoft.Json.JsonProperty("target", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        Uri Target { get; set; }

        [Newtonsoft.Json.JsonProperty("value", NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        string Value { get; set; }

    }
}

